!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("MobiusUtils",[],t):"object"==typeof exports?exports.MobiusUtils=t():e.MobiusUtils=t()}(this,(function(){return(()=>{var e={669:(e,t,r)=>{e.exports=r(609)},448:(e,t,r)=>{"use strict";var o=r(867),n=r(26),i=r(372),a=r(327),s=r(97),c=r(109),p=r(985),u=r(61);e.exports=function(e){return new Promise((function(t,r){var f=e.data,d=e.headers;o.isFormData(f)&&delete d["Content-Type"];var y=new XMLHttpRequest;if(e.auth){var l=e.auth.username||"",h=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";d.Authorization="Basic "+btoa(l+":"+h)}var m=s(e.baseURL,e.url);if(y.open(e.method.toUpperCase(),a(m,e.params,e.paramsSerializer),!0),y.timeout=e.timeout,y.onreadystatechange=function(){if(y&&4===y.readyState&&(0!==y.status||y.responseURL&&0===y.responseURL.indexOf("file:"))){var o="getAllResponseHeaders"in y?c(y.getAllResponseHeaders()):null,i={data:e.responseType&&"text"!==e.responseType?y.response:y.responseText,status:y.status,statusText:y.statusText,headers:o,config:e,request:y};n(t,r,i),y=null}},y.onabort=function(){y&&(r(u("Request aborted",e,"ECONNABORTED",y)),y=null)},y.onerror=function(){r(u("Network Error",e,null,y)),y=null},y.ontimeout=function(){var t="timeout of "+e.timeout+"ms exceeded";e.timeoutErrorMessage&&(t=e.timeoutErrorMessage),r(u(t,e,"ECONNABORTED",y)),y=null},o.isStandardBrowserEnv()){var g=(e.withCredentials||p(m))&&e.xsrfCookieName?i.read(e.xsrfCookieName):void 0;g&&(d[e.xsrfHeaderName]=g)}if("setRequestHeader"in y&&o.forEach(d,(function(e,t){void 0===f&&"content-type"===t.toLowerCase()?delete d[t]:y.setRequestHeader(t,e)})),o.isUndefined(e.withCredentials)||(y.withCredentials=!!e.withCredentials),e.responseType)try{y.responseType=e.responseType}catch(t){if("json"!==e.responseType)throw t}"function"==typeof e.onDownloadProgress&&y.addEventListener("progress",e.onDownloadProgress),"function"==typeof e.onUploadProgress&&y.upload&&y.upload.addEventListener("progress",e.onUploadProgress),e.cancelToken&&e.cancelToken.promise.then((function(e){y&&(y.abort(),r(e),y=null)})),f||(f=null),y.send(f)}))}},609:(e,t,r)=>{"use strict";var o=r(867),n=r(849),i=r(321),a=r(185);function s(e){var t=new i(e),r=n(i.prototype.request,t);return o.extend(r,i.prototype,t),o.extend(r,t),r}var c=s(r(655));c.Axios=i,c.create=function(e){return s(a(c.defaults,e))},c.Cancel=r(263),c.CancelToken=r(972),c.isCancel=r(502),c.all=function(e){return Promise.all(e)},c.spread=r(713),c.isAxiosError=r(268),e.exports=c,e.exports.default=c},263:e=>{"use strict";function t(e){this.message=e}t.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},t.prototype.__CANCEL__=!0,e.exports=t},972:(e,t,r)=>{"use strict";var o=r(263);function n(e){if("function"!=typeof e)throw new TypeError("executor must be a function.");var t;this.promise=new Promise((function(e){t=e}));var r=this;e((function(e){r.reason||(r.reason=new o(e),t(r.reason))}))}n.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},n.source=function(){var e;return{token:new n((function(t){e=t})),cancel:e}},e.exports=n},502:e=>{"use strict";e.exports=function(e){return!(!e||!e.__CANCEL__)}},321:(e,t,r)=>{"use strict";var o=r(867),n=r(327),i=r(782),a=r(572),s=r(185);function c(e){this.defaults=e,this.interceptors={request:new i,response:new i}}c.prototype.request=function(e){"string"==typeof e?(e=arguments[1]||{}).url=arguments[0]:e=e||{},(e=s(this.defaults,e)).method?e.method=e.method.toLowerCase():this.defaults.method?e.method=this.defaults.method.toLowerCase():e.method="get";var t=[a,void 0],r=Promise.resolve(e);for(this.interceptors.request.forEach((function(e){t.unshift(e.fulfilled,e.rejected)})),this.interceptors.response.forEach((function(e){t.push(e.fulfilled,e.rejected)}));t.length;)r=r.then(t.shift(),t.shift());return r},c.prototype.getUri=function(e){return e=s(this.defaults,e),n(e.url,e.params,e.paramsSerializer).replace(/^\?/,"")},o.forEach(["delete","get","head","options"],(function(e){c.prototype[e]=function(t,r){return this.request(s(r||{},{method:e,url:t,data:(r||{}).data}))}})),o.forEach(["post","put","patch"],(function(e){c.prototype[e]=function(t,r,o){return this.request(s(o||{},{method:e,url:t,data:r}))}})),e.exports=c},782:(e,t,r)=>{"use strict";var o=r(867);function n(){this.handlers=[]}n.prototype.use=function(e,t){return this.handlers.push({fulfilled:e,rejected:t}),this.handlers.length-1},n.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null)},n.prototype.forEach=function(e){o.forEach(this.handlers,(function(t){null!==t&&e(t)}))},e.exports=n},97:(e,t,r)=>{"use strict";var o=r(793),n=r(303);e.exports=function(e,t){return e&&!o(t)?n(e,t):t}},61:(e,t,r)=>{"use strict";var o=r(481);e.exports=function(e,t,r,n,i){var a=new Error(e);return o(a,t,r,n,i)}},572:(e,t,r)=>{"use strict";var o=r(867),n=r(527),i=r(502),a=r(655);function s(e){e.cancelToken&&e.cancelToken.throwIfRequested()}e.exports=function(e){return s(e),e.headers=e.headers||{},e.data=n(e.data,e.headers,e.transformRequest),e.headers=o.merge(e.headers.common||{},e.headers[e.method]||{},e.headers),o.forEach(["delete","get","head","post","put","patch","common"],(function(t){delete e.headers[t]})),(e.adapter||a.adapter)(e).then((function(t){return s(e),t.data=n(t.data,t.headers,e.transformResponse),t}),(function(t){return i(t)||(s(e),t&&t.response&&(t.response.data=n(t.response.data,t.response.headers,e.transformResponse))),Promise.reject(t)}))}},481:e=>{"use strict";e.exports=function(e,t,r,o,n){return e.config=t,r&&(e.code=r),e.request=o,e.response=n,e.isAxiosError=!0,e.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code}},e}},185:(e,t,r)=>{"use strict";var o=r(867);e.exports=function(e,t){t=t||{};var r={},n=["url","method","data"],i=["headers","auth","proxy","params"],a=["baseURL","transformRequest","transformResponse","paramsSerializer","timeout","timeoutMessage","withCredentials","adapter","responseType","xsrfCookieName","xsrfHeaderName","onUploadProgress","onDownloadProgress","decompress","maxContentLength","maxBodyLength","maxRedirects","transport","httpAgent","httpsAgent","cancelToken","socketPath","responseEncoding"],s=["validateStatus"];function c(e,t){return o.isPlainObject(e)&&o.isPlainObject(t)?o.merge(e,t):o.isPlainObject(t)?o.merge({},t):o.isArray(t)?t.slice():t}function p(n){o.isUndefined(t[n])?o.isUndefined(e[n])||(r[n]=c(void 0,e[n])):r[n]=c(e[n],t[n])}o.forEach(n,(function(e){o.isUndefined(t[e])||(r[e]=c(void 0,t[e]))})),o.forEach(i,p),o.forEach(a,(function(n){o.isUndefined(t[n])?o.isUndefined(e[n])||(r[n]=c(void 0,e[n])):r[n]=c(void 0,t[n])})),o.forEach(s,(function(o){o in t?r[o]=c(e[o],t[o]):o in e&&(r[o]=c(void 0,e[o]))}));var u=n.concat(i).concat(a).concat(s),f=Object.keys(e).concat(Object.keys(t)).filter((function(e){return-1===u.indexOf(e)}));return o.forEach(f,p),r}},26:(e,t,r)=>{"use strict";var o=r(61);e.exports=function(e,t,r){var n=r.config.validateStatus;r.status&&n&&!n(r.status)?t(o("Request failed with status code "+r.status,r.config,null,r.request,r)):e(r)}},527:(e,t,r)=>{"use strict";var o=r(867);e.exports=function(e,t,r){return o.forEach(r,(function(r){e=r(e,t)})),e}},655:(e,t,r)=>{"use strict";var o=r(867),n=r(16),i={"Content-Type":"application/x-www-form-urlencoded"};function a(e,t){!o.isUndefined(e)&&o.isUndefined(e["Content-Type"])&&(e["Content-Type"]=t)}var s,c={adapter:(("undefined"!=typeof XMLHttpRequest||"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process))&&(s=r(448)),s),transformRequest:[function(e,t){return n(t,"Accept"),n(t,"Content-Type"),o.isFormData(e)||o.isArrayBuffer(e)||o.isBuffer(e)||o.isStream(e)||o.isFile(e)||o.isBlob(e)?e:o.isArrayBufferView(e)?e.buffer:o.isURLSearchParams(e)?(a(t,"application/x-www-form-urlencoded;charset=utf-8"),e.toString()):o.isObject(e)?(a(t,"application/json;charset=utf-8"),JSON.stringify(e)):e}],transformResponse:[function(e){if("string"==typeof e)try{e=JSON.parse(e)}catch(e){}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};o.forEach(["delete","get","head"],(function(e){c.headers[e]={}})),o.forEach(["post","put","patch"],(function(e){c.headers[e]=o.merge(i)})),e.exports=c},849:e=>{"use strict";e.exports=function(e,t){return function(){for(var r=new Array(arguments.length),o=0;o<r.length;o++)r[o]=arguments[o];return e.apply(t,r)}}},327:(e,t,r)=>{"use strict";var o=r(867);function n(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}e.exports=function(e,t,r){if(!t)return e;var i;if(r)i=r(t);else if(o.isURLSearchParams(t))i=t.toString();else{var a=[];o.forEach(t,(function(e,t){null!=e&&(o.isArray(e)?t+="[]":e=[e],o.forEach(e,(function(e){o.isDate(e)?e=e.toISOString():o.isObject(e)&&(e=JSON.stringify(e)),a.push(n(t)+"="+n(e))})))})),i=a.join("&")}if(i){var s=e.indexOf("#");-1!==s&&(e=e.slice(0,s)),e+=(-1===e.indexOf("?")?"?":"&")+i}return e}},303:e=>{"use strict";e.exports=function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}},372:(e,t,r)=>{"use strict";var o=r(867);e.exports=o.isStandardBrowserEnv()?{write:function(e,t,r,n,i,a){var s=[];s.push(e+"="+encodeURIComponent(t)),o.isNumber(r)&&s.push("expires="+new Date(r).toGMTString()),o.isString(n)&&s.push("path="+n),o.isString(i)&&s.push("domain="+i),!0===a&&s.push("secure"),document.cookie=s.join("; ")},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},793:e=>{"use strict";e.exports=function(e){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)}},268:e=>{"use strict";e.exports=function(e){return"object"==typeof e&&!0===e.isAxiosError}},985:(e,t,r)=>{"use strict";var o=r(867);e.exports=o.isStandardBrowserEnv()?function(){var e,t=/(msie|trident)/i.test(navigator.userAgent),r=document.createElement("a");function n(e){var o=e;return t&&(r.setAttribute("href",o),o=r.href),r.setAttribute("href",o),{href:r.href,protocol:r.protocol?r.protocol.replace(/:$/,""):"",host:r.host,search:r.search?r.search.replace(/^\?/,""):"",hash:r.hash?r.hash.replace(/^#/,""):"",hostname:r.hostname,port:r.port,pathname:"/"===r.pathname.charAt(0)?r.pathname:"/"+r.pathname}}return e=n(window.location.href),function(t){var r=o.isString(t)?n(t):t;return r.protocol===e.protocol&&r.host===e.host}}():function(){return!0}},16:(e,t,r)=>{"use strict";var o=r(867);e.exports=function(e,t){o.forEach(e,(function(r,o){o!==t&&o.toUpperCase()===t.toUpperCase()&&(e[t]=r,delete e[o])}))}},109:(e,t,r)=>{"use strict";var o=r(867),n=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];e.exports=function(e){var t,r,i,a={};return e?(o.forEach(e.split("\n"),(function(e){if(i=e.indexOf(":"),t=o.trim(e.substr(0,i)).toLowerCase(),r=o.trim(e.substr(i+1)),t){if(a[t]&&n.indexOf(t)>=0)return;a[t]="set-cookie"===t?(a[t]?a[t]:[]).concat([r]):a[t]?a[t]+", "+r:r}})),a):a}},713:e=>{"use strict";e.exports=function(e){return function(t){return e.apply(null,t)}}},867:(e,t,r)=>{"use strict";var o=r(849),n=Object.prototype.toString;function i(e){return"[object Array]"===n.call(e)}function a(e){return void 0===e}function s(e){return null!==e&&"object"==typeof e}function c(e){if("[object Object]"!==n.call(e))return!1;var t=Object.getPrototypeOf(e);return null===t||t===Object.prototype}function p(e){return"[object Function]"===n.call(e)}function u(e,t){if(null!=e)if("object"!=typeof e&&(e=[e]),i(e))for(var r=0,o=e.length;r<o;r++)t.call(null,e[r],r,e);else for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.call(null,e[n],n,e)}e.exports={isArray:i,isArrayBuffer:function(e){return"[object ArrayBuffer]"===n.call(e)},isBuffer:function(e){return null!==e&&!a(e)&&null!==e.constructor&&!a(e.constructor)&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)},isFormData:function(e){return"undefined"!=typeof FormData&&e instanceof FormData},isArrayBufferView:function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&e.buffer instanceof ArrayBuffer},isString:function(e){return"string"==typeof e},isNumber:function(e){return"number"==typeof e},isObject:s,isPlainObject:c,isUndefined:a,isDate:function(e){return"[object Date]"===n.call(e)},isFile:function(e){return"[object File]"===n.call(e)},isBlob:function(e){return"[object Blob]"===n.call(e)},isFunction:p,isStream:function(e){return s(e)&&p(e.pipe)},isURLSearchParams:function(e){return"undefined"!=typeof URLSearchParams&&e instanceof URLSearchParams},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&"undefined"!=typeof window&&"undefined"!=typeof document},forEach:u,merge:function e(){var t={};function r(r,o){c(t[o])&&c(r)?t[o]=e(t[o],r):c(r)?t[o]=e({},r):i(r)?t[o]=r.slice():t[o]=r}for(var o=0,n=arguments.length;o<n;o++)u(arguments[o],r);return t},extend:function(e,t,r){return u(t,(function(t,n){e[n]=r&&"function"==typeof t?o(t,r):t})),e},trim:function(e){return e.replace(/^\s*/,"").replace(/\s*$/,"")},stripBOM:function(e){return 65279===e.charCodeAt(0)&&(e=e.slice(1)),e}}}},t={};function r(o){var n=t[o];if(void 0!==n)return n.exports;var i=t[o]={exports:{}};return e[o](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};return(()=>{"use strict";r.r(o),r.d(o,{BaseAtom:()=>ui,BaseMediator:()=>mi,DEFAULT_ERROR_RESPONSE_CODE:()=>dn,DEFAULT_FAIL_RESPONSE_CODE:()=>fn,DEFAULT_SUCCESS_RESPONSE_CODE:()=>un,DEFAULT_UNKNOWN_RESPONSE_CODE:()=>yn,Data:()=>li,Datar:()=>ii,Either:()=>et,FlatMediator:()=>$s,IO:()=>Ft,Identity:()=>Dt,Just:()=>Ot,Left:()=>tt,Maybe:()=>xt,Mutation:()=>di,Mutator:()=>ci,Nothing:()=>jt,ReplayMediator:()=>bi,Right:()=>rt,TERMINATOR:()=>ri,Task:()=>Ut,Terminator:()=>ti,TriggerMediator:()=>Ei,VACUO:()=>ni,VOID:()=>ei,Vacuo:()=>oi,Void:()=>Yn,Z:()=>Ce,adaptMultiPlatform:()=>On,adaptMultiPlatformAwait:()=>jn,addClass:()=>bo,allPass:()=>eo,always:()=>ge,and:()=>at,anyPass:()=>to,ap:()=>zt,apply:()=>Te,applyTo:()=>ve,argPlaceholder:()=>P,array:()=>In,arrayCaseT:()=>Qc,arrayCombineLatestT:()=>ip,arrayCombineT:()=>rp,arrayZipLatestT:()=>pp,asGetRequest:()=>Cn,asIs:()=>k,asIsDistinctEverT:()=>kc,asIsDistinctPreviousT:()=>Mc,asNull:()=>R,asPostRequest:()=>Mn,asUndefined:()=>$,assign:()=>jr,assignTo:()=>Lr,atomToData:()=>va,atomToMutation:()=>ja,axios:()=>Ln,beObservedBy:()=>Pa,between:()=>Jr,binary:()=>pe,binaryHyperComposeAtom:()=>es,binaryHyperPipeAtom:()=>Ya,binaryLiftComposeAtom:()=>Za,binaryLiftPipeAtom:()=>Qa,binaryTweenComposeAtom:()=>Ha,binaryTweenPipeAtom:()=>za,biu:()=>Sn,boolean:()=>Nn,caseT:()=>Gc,cata:()=>Ht,chain:()=>Vt,classArrToObj:()=>ao,classArrToStr:()=>po,classObjToArr:()=>co,classObjToStr:()=>uo,classStrToArr:()=>io,classStrToObj:()=>so,combineLatestT:()=>np,combineT:()=>tp,complement:()=>pt,completeStateD:()=>ls,completeStateRD:()=>hs,compose:()=>te,compose2:()=>Se,composeAtom:()=>Va,composeB:()=>Me,composeL:()=>X,composeR:()=>K,concat:()=>Ze,connectInterfaces:()=>wp,constant:()=>me,containClass:()=>Eo,converge:()=>Ae,createArrayMSTache:()=>zs,createArraySMTache:()=>qs,createAtomInArray:()=>Ra,createAtomInObject:()=>Na,createDataFromEvent:()=>qi,createDataFromFunction:()=>ca,createDataFromInterval:()=>Ji,createDataFromIterable:()=>Ni,createDataFromObservable:()=>oa,createDataFromTimeout:()=>Ki,createDataInArray:()=>Sa,createDataInObject:()=>_a,createDataOf:()=>da,createDataWithReplay:()=>Mi,createDataWithReplayMediator:()=>Li,createDataWithTrigger:()=>Di,createDataWithTriggerMediator:()=>Si,createEmptyData:()=>ua,createEmptyMutation:()=>fa,createEventTrigger:()=>Pi,createEventTriggerF:()=>Bi,createFunctionTrigger:()=>ia,createFunctionTriggerF:()=>sa,createGeneralDriver:()=>gp,createGeneralTache:()=>Us,createIntervalTrigger:()=>Vi,createIntervalTriggerF:()=>Hi,createIterableTrigger:()=>ki,createIterableTriggerF:()=>Ri,createMMTache:()=>Js,createMSTache:()=>Vs,createMutationFromEvent:()=>Wi,createMutationFromFunction:()=>pa,createMutationFromInterval:()=>Gi,createMutationFromIterable:()=>Ui,createMutationFromObservable:()=>na,createMutationFromTimeout:()=>Yi,createMutationInArray:()=>Da,createMutationInObject:()=>Fa,createMutationOf:()=>ya,createMutationOfLB:()=>ma,createMutationOfLL:()=>la,createMutationOfLR:()=>ha,createMutationWithReplay:()=>Ci,createMutationWithReplayMediator:()=>Ai,createMutationWithTrigger:()=>Fi,createMutationWithTriggerMediator:()=>_i,createObjectMSTache:()=>Hs,createObjectSMTache:()=>Ws,createObservableTrigger:()=>ea,createObservableTriggerF:()=>ra,createSMTache:()=>Bs,createSSTache:()=>Is,createTimeoutTrigger:()=>Qi,createTimeoutTriggerF:()=>Xi,curry:()=>H,curryN:()=>G,curryS:()=>q,dataToData:()=>Ta,dataToMutation:()=>xa,dataToMutationS:()=>Ea,debounce:()=>Nr,debounceTimeT:()=>fc,deepCopy:()=>Dr,deepCopyViaJSON:()=>Cr,defaultProps:()=>Ar,defaultToT:()=>Zs,distinctEverT:()=>Cc,distinctPreviousT:()=>Ac,documentD:()=>Ts,documentRD:()=>vs,domLoadedD:()=>as,domLoadedRD:()=>ss,duplication:()=>Oe,dynamicArrayCaseT:()=>Zc,dynamicDebounceTimeT:()=>dc,dynamicDefautToT:()=>Xs,dynamicDistinctEverT:()=>Dc,dynamicDistinctPreviousT:()=>Sc,dynamicEffectT:()=>yp,dynamicEmptyStartWithT:()=>pc,dynamicFilterT:()=>ns,dynamicIifT:()=>Hc,dynamicMapT:()=>oc,dynamicObjectCaseT:()=>Yc,dynamicPluckT:()=>ec,dynamicSkipT:()=>Rc,dynamicStartWithT:()=>ac,dynamicSwitchT:()=>Oc,dynamicTakeT:()=>Bc,dynamicThrottleTimeT:()=>hc,effectT:()=>dp,either:()=>it,eitherToMaybe:()=>er,emptifyObj:()=>Mr,emptyStartWithT:()=>cc,entries:()=>wr,equals:()=>gt,every:()=>$e,filter:()=>Ue,filterFalsy:()=>Yr,filterT:()=>os,filterTruthy:()=>Kr,flat:()=>qe,flip:()=>we,forEach:()=>Ne,formatClassTo:()=>ho,formatErrorResponse:()=>mn,formatEventTriggerCreatorFlatArgs:()=>Ii,formatFailResponse:()=>hn,formatFunctionTriggerCreatorFlatArgs:()=>aa,formatIntervalTriggerCreatorFlatArgs:()=>zi,formatIterableTriggerCreatorFlatArgs:()=>$i,formatObservableTriggerCreatorFlatArgs:()=>ta,formatResponse:()=>bn,formatResponseMakerFlattenArgs:()=>Ho,formatSuccessResponse:()=>ln,formatTimeoutTriggerCreatorFlatArgs:()=>Zi,formatUnknownResponse:()=>gn,get:()=>Sr,getAtomType:()=>Ia,getByPath:()=>_r,globalVar:()=>Ls,hardDeepMerge:()=>Fr,hasOwnProperty:()=>Or,hasValidResponseCode:()=>on,humanize:()=>or,identity:()=>le,ifElse:()=>wt,iif:()=>Et,iifT:()=>zc,iife:()=>$r,includes:()=>ke,indexOf:()=>ur,injectScript:()=>Es,inspect:()=>Jn,interactiveStateD:()=>ds,interactiveStateRD:()=>ys,internalCurry:()=>z,internalCurryN:()=>J,internalLooseCurry:()=>W,internalLooseCurryN:()=>Q,intersection:()=>Ke,invoker:()=>ie,io:()=>kt,is:()=>qn,isAllSpace:()=>lr,isApplicative:()=>Bt,isArgPlaceholder:()=>I,isArray:()=>y,isAsyncFn:()=>T,isAsyncGeneratorFunction:()=>E,isAtom:()=>pi,isBoolean:()=>n,isData:()=>yi,isDatar:()=>Gn,isDate:()=>f,isDefined:()=>e,isDocument:()=>_,isEmailAddress:()=>Xr,isEmpty:()=>F,isEmptyArr:()=>j,isEmptyObj:()=>L,isEmptyStr:()=>O,isError:()=>x,isErrorResponse:()=>cn,isEven:()=>Br,isEventTarget:()=>M,isFailResponse:()=>sn,isFalse:()=>ft,isFalsy:()=>yt,isFlatMediator:()=>ks,isFunction:()=>u,isFunctor:()=>Pt,isGeneralObject:()=>t,isGeneratorFunction:()=>v,isInBrowser:()=>vn,isInNode:()=>En,isInWXMINA:()=>wn,isInWeb:()=>Tn,isIterable:()=>C,isMap:()=>l,isMediator:()=>hi,isMonad:()=>It,isMonoid:()=>qt,isMutation:()=>fi,isMutator:()=>Qn,isNil:()=>lt,isNotNil:()=>ht,isNull:()=>p,isNumber:()=>a,isObject:()=>d,isObservable:()=>D,isOdd:()=>qr,isOutDated:()=>A,isPathnameEqual:()=>Fo,isPathnameLooseEqual:()=>Do,isPathnameStrictEqual:()=>Co,isPhoneNum:()=>Gr,isPromise:()=>w,isQQId:()=>Zr,isRegExp:()=>b,isReplayMediator:()=>gi,isResponse:()=>nn,isResponseCode:()=>rn,isSameTypeOfAtom:()=>Ba,isSameTypeOfMediator:()=>qa,isSet:()=>m,isStartWith:()=>yr,isString:()=>i,isSuccessResponse:()=>an,isSymbol:()=>s,isTelNum:()=>Qr,isTerminator:()=>Xn,isTriggerMediator:()=>vi,isTrue:()=>ut,isTruthy:()=>dt,isUndefined:()=>c,isUnknowResponse:()=>pn,isVacuo:()=>Kn,isVoid:()=>Zn,isWeakMap:()=>h,isWeakSet:()=>g,isWindow:()=>S,join:()=>Ve,just:()=>Lt,keys:()=>Tr,kite:()=>be,left:()=>ot,lift:()=>Gt,liftA2:()=>Qt,liftA3:()=>Zt,liftA4:()=>Xt,liftA5:()=>Kt,liftN:()=>Jt,looseBinary:()=>ue,looseCurry:()=>V,looseCurryN:()=>Z,looseCurryS:()=>B,looseEquals:()=>bt,looseInvoker:()=>ae,looseNAry:()=>ce,looseUnary:()=>de,makeBaseResponse:()=>zo,makeCustomEvent:()=>xs,makeElementBasedMessageProxy:()=>Ms,makeErrorResponse:()=>Qo,makeErrorResponseF:()=>Yo,makeEventHandler:()=>As,makeFailResponse:()=>Go,makeFailResponseF:()=>Ko,makeGeneralEventHandler:()=>Ss,makeLinedTigerLogger:()=>Hn,makeScopeManager:()=>Fs,makeSuccessResponse:()=>Jo,makeSuccessResponseF:()=>Xo,makeTigerLogger:()=>zn,makeUniqueString:()=>oo,makeUnknownResponse:()=>Zo,makeUnknownResponseF:()=>en,map:()=>Re,mapT:()=>rc,maxOf:()=>Hr,maxTo:()=>Wr,maybe:()=>Ct,maybeToEither:()=>Yt,memorize:()=>oe,mergeT:()=>sp,minOf:()=>zr,minTo:()=>Vr,modifyBiuConfig:()=>_n,mutationToData:()=>wa,mutationToDataS:()=>ba,mutationToMutation:()=>Oa,nAry:()=>se,nAryHyperComposeAtom:()=>rs,nAryHyperPipeAtom:()=>ts,nAryLiftComposeAtom:()=>Ka,nAryLiftPipeAtom:()=>Xa,nAryTweenComposeAtom:()=>Ga,nAryTweenPipeAtom:()=>Ja,neatenClassStr:()=>no,neatenPathname:()=>So,neatenQueryStr:()=>$o,neatenSearch:()=>ko,nilToVoidT:()=>Gs,noop:()=>N,not:()=>ct,nothing:()=>At,number:()=>Pn,object:()=>Bn,objectCaseT:()=>Kc,objectCombineLatestT:()=>ap,objectCombineT:()=>op,objectZipLatestT:()=>up,observe:()=>Ua,of:()=>Wt,omega:()=>he,once:()=>Rr,or:()=>st,orElse:()=>_t,orJust:()=>Mt,packing:()=>Ir,pairwiseT:()=>Tc,partitionT:()=>Qs,pathnameToArray:()=>_o,pathnameToString:()=>Mo,perf:()=>Wn,perform:()=>Rt,performUnsafeIO:()=>Nt,pipe:()=>re,pipeAtom:()=>Wa,pipeL:()=>Y,pipeR:()=>ee,pluckT:()=>Ys,pollingToGetNode:()=>Os,pop:()=>He,prefixClassWith:()=>mo,promiseSwitchT:()=>Lc,prop:()=>gr,propEq:()=>br,psi:()=>_e,push:()=>ze,queryObjToQueryStr:()=>No,queryObjToSearch:()=>Bo,queryStrToQueryObj:()=>Ro,queryStrToSearch:()=>Io,randomString:()=>mr,readyStateD:()=>us,readyStateRD:()=>fs,reduce:()=>Ie,reject:()=>Pe,removeClass:()=>wo,removePrefixOfClass:()=>go,removeRepetition:()=>xo,removeRepetitionExcept:()=>jo,removeRepetitionOf:()=>Oo,removeRepetitionOfEmpty:()=>Lo,removeRepetitionOfSlash:()=>Ao,replace:()=>dr,replaceClass:()=>vo,replayWithLatest:()=>Ti,replayWithoutLatest:()=>wi,right:()=>nt,run:()=>$t,safe:()=>St,searchToQueryObj:()=>Po,searchToQueryStr:()=>Uo,semantic:()=>vp,shift:()=>Ge,shuffle:()=>Fe,skipT:()=>$c,skipUntilT:()=>Uc,skipWhileT:()=>Pc,slice:()=>We,smartDeepMerge:()=>kr,some:()=>Be,split:()=>fr,startWithT:()=>ic,staticArrayCaseT:()=>Xc,staticDebounceTimeT:()=>yc,staticDefaultToT:()=>Ks,staticDistinctEverT:()=>Fc,staticDistinctPreviousT:()=>_c,staticEffectT:()=>lp,staticEmptyStartWithT:()=>uc,staticFilterT:()=>is,staticIifT:()=>Jc,staticMapT:()=>nc,staticObjectCaseT:()=>ep,staticPluckT:()=>tc,staticSkipT:()=>Nc,staticStartWithT:()=>sc,staticSwitchT:()=>jc,staticTakeT:()=>qc,staticThrottleTimeT:()=>mc,stdLineLog:()=>Vn,strictEquals:()=>mt,string:()=>Un,struct:()=>Rn,substitution:()=>je,substitution2:()=>Le,switchT:()=>xc,takeT:()=>Ic,takeUntilT:()=>Wc,takeWhileT:()=>Vc,tap:()=>ye,tapT:()=>hp,tapValueT:()=>mp,throttle:()=>Ur,throttleTime:()=>Pr,throttleTimeT:()=>lc,thrush:()=>Ee,toArray:()=>De,toClassArr:()=>yo,toClassObj:()=>lo,toClassStr:()=>fo,toLowerCase:()=>ir,toQueryObj:()=>Vo,toQueryStr:()=>Wo,toSearch:()=>qo,toString:()=>nr,toUpperCase:()=>ar,toggleClass:()=>To,trim:()=>sr,trimLeft:()=>pr,trimRight:()=>cr,truthyKeys:()=>Er,truthyPairwiseT:()=>vc,truthyValues:()=>xr,unary:()=>fe,union:()=>Xe,unique:()=>Qe,unless:()=>vt,unshift:()=>Je,useGeneralDriver:()=>Tp,useGeneralTache:()=>Ps,values:()=>vr,vireo:()=>xe,when:()=>Tt,windowD:()=>bs,windowLoadedD:()=>cs,windowLoadedRD:()=>ps,windowRD:()=>ws,windowResizeD:()=>ms,windowResizeRD:()=>gs,withCredentials:()=>Fn,withDataExtracted:()=>$n,withDynamicHistoryT:()=>bc,withHistoryT:()=>gc,withJSONContent:()=>Dn,withLatestFromT:()=>fp,withMediator:()=>xi,withReplayMediator:()=>Oi,withStaticHistoryT:()=>wc,withTriggerMediator:()=>ji,withValueFlatted:()=>Rs,withoutCredentials:()=>kn,wxmina:()=>xn,zipLatestT:()=>cp});const e=e=>void 0!==e,t=e=>"object"==typeof e,n=e=>"[object Boolean]"===Object.prototype.toString.call(e),i=e=>"[object String]"===Object.prototype.toString.call(e),a=e=>"[object Number]"===Object.prototype.toString.call(e),s=e=>"[object Symbol]"===Object.prototype.toString.call(e),c=e=>"[object Undefined]"===Object.prototype.toString.call(e),p=e=>"[object Null]"===Object.prototype.toString.call(e),u=e=>e&&"[object Function]"===Object.prototype.toString.call(e),f=e=>e&&"[object Date]"===Object.prototype.toString.call(new Date(e))&&!!new Date(e).getTime(),d=e=>"[object Object]"===Object.prototype.toString.call(e),y=e=>"[object Array]"===Object.prototype.toString.call(e),l=e=>"[object Map]"===Object.prototype.toString.call(e),h=e=>"[object WeakMap]"===Object.prototype.toString.call(e),m=e=>"[object Set]"===Object.prototype.toString.call(e),g=e=>"[object WeakSet]"===Object.prototype.toString.call(e),b=e=>"[object RegExp]"===Object.prototype.toString.call(e),w=e=>"[object Promise]"===Object.prototype.toString.call(e),T=e=>"[object AsyncFunction]"===Object.prototype.toString.call(e),v=e=>"[object GeneratorFunction]"===Object.prototype.toString.call(e),E=e=>"[object AsyncGeneratorFunction]"===Object.prototype.toString.call(e),x=e=>"[object Error]"===Object.prototype.toString.call(e),O=e=>i(e)&&0===e.length,j=e=>y(e)&&0===e.length,L=e=>d(e)&&0===Object.keys(e).length,A=e=>f(e)&&new Date(e).getTime()<(new Date).getTime(),S=e=>"[object Window]"===Object.prototype.toString.call(e),_=e=>"[object HTMLDocument]"===Object.prototype.toString.call(document),M=e=>e instanceof EventTarget,C=e=>"object Function"===Object.prototype.toString.call(e[Symbol.iterator]),D=e=>d(e)&&(e.isObservable||u(e.subscribe)),F=e=>p(e)||c(e)||O(e)||j(e)||L(e)||d(e)&&e.isEmpty,k=e=>e,$=e=>{},R=e=>null,N=e=>{},U=e=>te((e=>!e),e),P={"@@functional/placeholder":!0,isArgPlaceholder:!0},I=e=>d(e)&&Object.prototype.hasOwnProperty.call(e,"isArgPlaceholder")&&e.isArgPlaceholder,B=(e,...t)=>t.length>=e.length?e(...t):(...r)=>B(e,...t,...r),q=(e,...t)=>{const r=e.length;return t.length>=r?e(...t.slice(0,r)):(...r)=>q(e,...t,...r)},W=(e,t,...r)=>{let o=t||[];o=o.map((e=>I(e)&&r.length>0?r.shift():e)),o=o.concat(r);const n=e.length;return o.slice(0,n).filter(U(I)).length>=n?e(...o):(...t)=>W(e,o,...t)},V=(e,...t)=>W(e,[],...t),z=(e,t,...r)=>{let o=t||[];o=o.map((e=>I(e)&&r.length>0?r.shift():e)),o=o.concat(r);const n=e.length,i=o.slice(0,n);return i.filter(U(I)).length>=n?e(...i):(...t)=>z(e,i,...t)},H=(e,...t)=>z(e,[],...t),J=(e,t,r,...o)=>{let n=r||[];n=n.map((e=>I(e)&&o.length>0?o.shift():e)),n=n.concat(o);const i=n.slice(0,e);return i.filter(U(I)).length>=e?t(...i):(...r)=>J(e,t,i,...r)},G=(e,t,...r)=>J(e,t,[],...r),Q=(e,t,r,...o)=>{let n=r||[];return n=n.map((e=>I(e)&&o.length>0?o.shift():e)),n=n.concat(o),n.slice(0,e).filter(U(I)).length>=e?t(...n):(...r)=>Q(e,t,n,...r)},Z=(e,t,...r)=>Q(e,t,[],...r),X=(...e)=>e.reduce(((e,t)=>(...r)=>t(e(...r))),e.shift()||k),K=(...e)=>X(...e.reverse()),Y=K,ee=X,te=K,re=X,oe=(e,t)=>{const r={};return t=t||((...e)=>JSON.stringify(e)),(...o)=>{const n=t(o);return r[n]||(r[n]=e.apply(void 0,o)),r[n]}},ne=e=>(t,r)=>e(t,((...e)=>{const t=e[e.length-1];if(!t[r])throw Error(`Can not find "${r}" method in target.'`);if(!u(t[r]))throw Error(`"${r}" property in target is not a function.`);return t[r](...e.slice(0,e.length-1))})),ie=ne(G),ae=ne(Z),se=H(((e,t)=>G(e,t))),ce=H(((e,t)=>Z(e,t))),pe=e=>H(((t,r)=>e(t,r))),ue=e=>V(((t,r,...o)=>e(t,r,...o))),fe=e=>t=>e(t),de=e=>(t,...r)=>e(t,...r),ye=e=>(...t)=>(e(...t),t[0]),le=e=>e,he=e=>e(e),me=e=>()=>e,ge=me,be=e=>e=>e,we=G(3,((e,t,r)=>H(e)(r)(t))),Te=G(2,((e,t)=>e(t))),ve=G(2,((e,t)=>t(e))),Ee=ve,xe=G(3,((e,t,r)=>H(r)(e)(t))),Oe=G(2,((e,t)=>H(e)(t)(t))),je=G(3,((e,t,r)=>H(e)(r)(t(r)))),Le=G(3,((e,t,r)=>H(e)(t(r))(r))),Ae=G(4,((e,t,r,o)=>H(e)(t(o))(r(o)))),Se=G(5,((e,t,r,o,n)=>H(e)(t(o))(r(n)))),_e=G(4,((e,t,r,o)=>H(e)(t(r))(t(o)))),Me=G(3,((e,t,r)=>e(t(r)))),Ce=e=>{return t=t=>e(((...e)=>t(t)(...e))),e(((...e)=>t(t)(...e)));var t},De=e=>[...e],Fe=e=>{for(let t=(e=[].concat(e)).length;t;t--){const r=Math.floor(Math.random()*t);[e[t-1],e[r]]=[e[r],e[t-1]]}return e},ke=ie(2,"includes"),$e=ie(2,"every"),Re=ie(2,"map"),Ne=ie(2,"forEach"),Ue=ie(2,"filter"),Pe=H(((e,t)=>Ue(((...t)=>!e(...t)),t))),Ie=ie(3,"reduce"),Be=ie(2,"some"),qe=ie(1,"flat"),We=ie(3,"slice"),Ve=ie(2,"join"),ze=H(((e,t)=>((t=[...t]).push(e),t))),He=e=>((e=[...e]).pop(),e),Je=H(((e,t)=>((t=[...t]).unshift(e),t))),Ge=e=>((e=[...e]).shift(),e),Qe=e=>[...new Set(e)],Ze=ie(2,"concat"),Xe=G(2,te(Qe,we(Ze))),Ke=H(((e,t)=>{const r=((e,t)=>e.length>t.length?e:t)(e,t),o=((e,t)=>e.length>t.length?t:e)(e,t);return Qe(Ue(we(ke)(r),o))})),Ye=e=>{return e&&"function"==typeof e.inspect?e.inspect():"function"==typeof e?(r=e).name?r.name:r.toString():(t=e,Array.isArray(t)?`[${t.map(Ye).join(", ")}]`:function(e){switch(typeof e){case"string":return`'${e}'`;case"object":return`{${Object.keys(e).map((t=>[t,Ye(e[t])])).map((e=>e.join(": "))).join(", ")}}`;default:return String(e)}}(t));var t,r};class et{constructor(e){this._value=e}get value(){return this._value}static of(e){return new rt(e)}static right(e){return new rt(e)}static left(e){return new tt(e)}}class tt extends et{get isLeft(){return!0}get isRight(){return!1}static of(e){throw new Error("`of` called on class Left (value) instead of Either (type)")}inspect(){return`Left(${Ye(this._value)})`}map(){return this}join(){return this}chain(){return this}ap(){return this}cata({Left:e,Right:t}){return e(this._value)}sequence(e){return e(this)}traverse(e,t){return e(this)}}class rt extends et{get isLeft(){return!1}get isRight(){return!0}static of(e){throw new Error("`of` called on class Right (value) instead of Either (type)")}inspect(){return`Right(${Ye(this._value)})`}map(e){return et.of(e(this._value))}join(){return this._value}chain(e){return e(this._value)}ap(e){return this.map(e._value)}cata({Left:e,Right:t}){return t(this._value)}sequence(e){return this.traverse(e,le)}traverse(e,t){t(this._value).map(et.of)}}const ot=e=>new tt(e),nt=e=>new rt(e),it=H(((e,t,r)=>r.isLeft?e(r.value):t(r.value))),at=H(((e,t)=>!!e&&!!t)),st=H(((e,t)=>!!e||!!t)),ct=e=>!e,pt=e=>te(ct,e),ut=e=>!0===e,ft=e=>!1===e,dt=e=>1==!!e,yt=e=>0==!!e,lt=e=>null==e,ht=pt(lt),mt=H(((e,t)=>e===t)),gt=mt,bt=H(((e,t)=>e==t)),wt=H(((e,t,r,o)=>e(o)?t(o):r(o))),Tt=H(((e,t,r)=>e(r)?t(r):r)),vt=H(((e,t,r)=>e(r)?r:t(r))),Et=H(((e,t,r)=>e?t:r));class xt{static of(e){return xt.just(e)}static just(e){return new Ot(e)}static nothing(){return new jt}static fromNullable(e){return p(e)?xt.nothing():xt.just(e)}static fromUndefinedable(e){return c(e)?xt.nothing():xt.just(e)}static fromFalsyable(e){return yt(e)?xt.nothing():xt.just(e)}static fromNilable(e){return lt(e)?xt.nothing():xt.just(e)}static fromEmptyable(e){return F(e)?xt.nothing():xt.just(e)}get isNothing(){return!1}get isJust(){return!1}get isMaybe(){return!0}}class Ot extends xt{constructor(e){super(),this._value=e}get value(){return this._value}get isJust(){return!0}get isNothing(){return!1}inspect(){return`Maybe.Just(${Ye(this._value)})`}map(e){return xt.just(e(this._value))}join(){return this._value}chain(e){return e(this._value)}ap(e){return this.map(e._value)}orJust(){return this}orElse(){return this}filter(e){return e(this._value)?this:xt.nothing()}cata({Just:e,Nothing:t}){return e(this._value)}}class jt extends xt{get value(){throw new TypeError("Can't extract the value of a Nothing.")}get isNothing(){return!0}get isJust(){return!1}inspect(){return"Maybe.Nothing"}map(e){return this}join(){return this}chain(e){return this}ap(e){return this}orJust(e){return xt.of(e)}orElse(e){return e}filter(){return this}cata({Just:e,Nothing:t}){return t()}}const Lt=e=>new Ot(e),At=()=>new jt,St=H(((e,t)=>e(t)?Lt(t):At())),_t=ie(2,"orElse"),Mt=ie(2,"orJust"),Ct=H(((e,t,r)=>r.isNothing?e:t(r.value)));class Dt{constructor(e){this._value=e}of(e){return new Dt(e)}get value(){return this._value}get isIdentity(){return!0}inspect(){return`Identity(${Ye(this._value)})`}map(e){return Dt.of(e(this._value))}join(){return this._value}chain(e){return e(this._value)}sequence(e){return this.traverse(e,le)}traverse(e,t){return t(this._value).map(Dt.of)}}class Ft{constructor(e){if(!u(e))throw new Error("IO requires a function.");this._value=e}static of(e){return new Ft(e)}static const(e){return new Ft(me(e))}get isIO(){return!0}inspect(){return`IO(${Ye(this._value)})`}run(...e){return this._value(...e)}perform(...e){return this._value(...e)}performUnsafeIO(...e){return this._value(...e)}map(e){return new Ft(te(e,this._value))}join(){return new Ft((()=>this.performUnsafeIO().performUnsafeIO()))}chain(e){return this.map(e).join()}ap(e){return this.chain(e._value)}}const kt=e=>new Ft(e),$t=Z(1,((e,...t)=>e.run(...t))),Rt=Z(1,((e,...t)=>e.perform(...t))),Nt=Z(1,((e,...t)=>e.performUnsafeIO(...t)));class Ut{constructor(e){this._value=e}static of(e){return new Ut((({reject:t,resolve:r})=>r(e)))}get isTask(){return!0}inspect(){return`Task(${Ye(this._value)})`}fork({reject:e,resolve:t}){return this._value({reject:e,resolve:t})}map(e){return new Ut((({reject:t,resolve:r})=>this.fork({reject:t,resolve:t=>r(e(t))})))}join(){return new Ut((({reject:e,resolve:t})=>this.fork({reject:e,resolve:r=>r.fork({reject:e,resolve:e=>t(e)})})))}chain(e){return new Ut((({reject:t,resolve:r})=>this.fork({reject:t,resolve:o=>e(o).fork({reject:t,resolve:r})})))}ap(e){return this.map(e._value)}}const Pt=e=>{},It=e=>{},Bt=e=>{},qt=e=>{},Wt=ie(2,"of"),Vt=ie(2,"chain"),zt=ie(2,"ap"),Ht=ie(1,"cata"),Jt=H(((e,t)=>{const r=G(e,t);return G(e,((...e)=>Ie(zt,e[0].map(r),e.slice(1))))})),Gt=e=>Jt(e.length,e),Qt=Jt(2),Zt=Jt(3),Xt=Jt(4),Kt=Jt(5),Yt=(e,t)=>t.isNothing?et.left(e):t.chain(et.right),er=e=>e.isLeft?xt.nothing():e.chain(xt.just),tr={year:"年",month:"月",week:"周",day:"天",hour:"小时",minute:"分钟",second:"秒",millisecond:"毫秒"},rr={year:315576e5,month:26298e5,week:6048e5,day:864e5,hour:36e5,minute:6e4,second:1e3,millisecond:1},or=e=>{let t="";const r=+new Date-e;for(const e in rr)if(r>=rr[e]){t=`${Math.floor(r/rr[e])} ${tr[e]}前`;break}return t||"刚刚"},nr=ie(1,"toString"),ir=ie(1,"toLowerCase"),ar=ie(1,"toUpperCase"),sr=ie(1,"trim"),cr=ie(1,"trimRight"),pr=ie(1,"trimLeft"),ur=ie(2,"indexOf"),fr=ie(2,"split"),dr=ie(3,"replace"),yr=H(((e,t)=>0===ur(e,t))),lr=e=>!!sr(e),hr={},mr=(e,t)=>{let r="";t=t||"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";for(let o=e;o>0;--o)r+=t[Math.floor(Math.random()*t.length)];hr[e]=hr[e]||[];const o=hr[e];return o.includes(r)?mr():(o.push(r),r)},gr=H(((e,t)=>t[e])),br=H(((e,t,r)=>r[e]===t)),wr=Object.entries,Tr=Object.keys,vr=Object.values,Er=e=>wr(e).filter((([e,t])=>!!t)).map((([e,t])=>e)),xr=e=>wr(e).filter((([e,t])=>!!t)).map((([e,t])=>t)),Or=H(((e,t)=>Object.prototype.hasOwnProperty.call(t,e))),jr=G(2,((e,t)=>t.assign(e))),Lr=G(2,((e,t)=>e.assign(t))),Ar=jr,Sr=H(((e,t)=>{const r=te(Ue(dt),fr(/[,[/\].]+?/),dr(/['|"]/g,""));return Ie(((e,t)=>lt(e)?e:e[t]),e)(r(t))})),_r=H(((e,t)=>{const r=te(Ue(dt),fr(/[,./[\]\\]/g),dr(/['|"]/g,""));return Ie(((e,t)=>lt(e)?e:e[t]),t)(r(e))})),Mr=e=>{for(const t in e)d(e[t])?Mr(e[t]):delete e[t];return e},Cr=e=>JSON.parse(JSON.stringify(e)),Dr=e=>{if(!d(e))return e;const t=y(e)?[]:{};for(const r in e)d(e[r])?t[r]=Dr(e[r]):t[r]=e[r];return t},Fr=H(((e,t)=>d(e)&&d(t)?(Object.keys(t).forEach((r=>{const o=e[r],n=t[r];y(o)&&y(n)?e[r]=Dr(n):d(o)&&d(n)?e[r]=Fr(o,n):e[r]=n})),e):e)),kr=(e,t)=>d(e)&&d(t)?(Object.keys(t).forEach((r=>{const o=e[r],n=t[r];y(o)&&y(n)?e[r]=o.concat(n):d(o)&&d(n)?e[r]=kr(o,n):e[r]=n})),e):e,$r=(e,...t)=>e(...t),Rr=e=>{let t,r;return(...o)=>(t||(t=!0,r=e(...o)),r)},Nr=(e,t)=>{let r,o=[];return()=>(clearTimeout(r),r=setTimeout((async()=>{const t=await e();o.forEach((e=>{e(t)})),o=[]}),t),new Promise((e=>{o.push(e)})))},Ur=e=>{let t=!1,r=[];return()=>(t||(t=!0,Promise.resolve(e()).then((e=>{r.forEach((t=>{t(e)})),r=[],t=!1}))),new Promise((e=>{r.push(e)})))},Pr=(e,t)=>{let r=!1,o=[];return()=>(r||(r=!0,Promise.resolve(e()).then((e=>{o.forEach((t=>{t(e)})),o=[]})),setTimeout((()=>{r=!1}),t)),new Promise((e=>{o.push(e)})))},Ir=(e,t)=>{let r,o=[],n={};return i=>(clearTimeout(r),n=Fr(n,i),r=setTimeout((async()=>{const t=await e(n);o.forEach((e=>{e(t)})),o=[]}),t),new Promise((e=>{o.push(e)})))},Br=e=>e%2==0,qr=e=>e%2!=0,Wr=G(2,((e,t)=>t>e?e:t)),Vr=G(2,((e,t)=>t<e?e:t)),zr=G(2,((e,t)=>e<t?e:t)),Hr=G(2,((e,t)=>e>t?e:t)),Jr=G(3,((e,t,r)=>{const o=zr(e,t),n=Hr(e,t);return r<o?o:r>n?n:r})),Gr=e=>/^1[3-9]\d{9}$/.test(e),Qr=e=>/^(\(\d{3,4}\)|\d{3,4}-|\s)?\d{7,14}$/.test(e),Zr=e=>/^[1-9][0-9]{4,10}$/.test(e),Xr=e=>/^([A-Za-z0-9_\-.])+@([A-Za-z0-9_\-.])+\.([A-Za-z]{2,4})$/.test(e),Kr=Ue(dt),Yr=Ue(yt),eo=H(((e,t)=>$e(ve(t),e))),to=H(((e,t)=>Be(ve(t),e))),ro="mobius".split(""),oo=(e="unique")=>{ro.unshift(ro.pop());const t=ro.join("");return`${e}--${+new Date}-${t}`},no=e=>{if(!i(e))throw new TypeError(`"str" is expected to be type of String, but received typeof "${e}".`);return e.replace("."," ").replace(/\s+/g," ").trim()},io=e=>{if(!i(e))throw new TypeError(`"str" is expected to be type of String, but received typeof "${e}".`);return no(e).split(" ").filter((e=>e.length>0))},ao=e=>{if(!y(e))throw new TypeError(`"arr" is expected to be type of Array, but received typeof "${e}".`);return e.flat(1/0).filter(i).reduce(((e,t)=>(e[t]=!0,e)),{})},so=e=>{if(!i(e))throw new TypeError(`"str" is expected to be type of String, but received typeof "${e}".`);const t=io(e);return ao(t)},co=e=>{if(!d(e))throw new TypeError(`"obj" is expected to be type of Object, but received typeof "${e}".`);return Object.entries(e).reduce(((e,[t,r])=>(!0===r&&e.push(t),e)),[])},po=e=>{if(!y(e))throw new TypeError(`"arr" is expected to be type of Array, but received typeof "${e}".`);return e.flat(1/0).filter(i).filter((e=>e.length>0)).join(" ")},uo=e=>{if(!d(e))throw new TypeError(`"obj" is expected to be type of Object, but received typeof "${e}".`);const t=co(e);return po(t)},fo=e=>{if(i(e))return""+e;if(y(e))return po(e);if(d(e))return uo(e);throw new TypeError(`"tar" is expected to be type of String | Array | Object, but received typeof ${e}`)},yo=e=>{if(i(e))return io(e);if(y(e))return[...e.flat(1/0).filter(i)];if(d(e))return co(e);throw new TypeError(`"tar" is expected to be type of String | Array | Object, but received typeof ${e}`)},lo=e=>{if(i(e))return so(e);if(y(e))return ao(e);if(d(e))return{...e};throw new TypeError(`"tar" is expected to be type of String | Array | Object, but received typeof ${e}`)},ho=G(2,((e,t)=>{if(i(e))return fo(t);if(d(e))return lo(t);if(y(e))return yo(t);throw new TypeError(`"target" is expected to be type of String | Array | Object, but received typeof ${e}`)})),mo=G(2,((e,t)=>{if(i(t)){const r=io(t).map((t=>0===t.indexOf(e)?t:e+t));return po(r)}if(d(t))return Object.entries(t).reduce(((t,[r,o])=>(t[0===r.indexOf(e)?r:e+r]=o,t)),{});if(y(t))return t.map((t=>0===t.indexOf(e)?t:e+t));throw new Error(`"cls"(aka. class) is expected to be type of String | Array | Object, but received ${t}`)})),go=G(2,((e,t)=>{if(i(t))return io(t).map((t=>0===t.indexOf(e)?t.slice(e.length):t)).join(" ");if(d(t))return Object.entries(t).reduce(((t,[r,o])=>(0===r.indexOf(e)?t[r.slice(e.length)]=o:t[r]=o,t)),{});if(y(t))return t.map((t=>0===t.indexOf(e)?t.slice(e.length):t));throw new Error(`"cls"(aka. class) is expected to be type of String | Array | Object, but received ${t}`)})),bo=G(2,((e,t)=>{const r=lo(e),o={...lo(t),...r};return ho(t,o)})),wo=G(2,((e,t)=>{const r=lo(e);Object.keys(r).forEach((e=>{r[e]=!1}));const o={...lo(t),...r};return ho(t,o)})),To=G(2,((e,t)=>{const r=yo(e),o=lo(t);return r.forEach((e=>{o[e]=!o[e]})),ho(t,o)})),vo=G(2,((e,t)=>{if(d(e)){const r=lo(t);return Object.entries(e).forEach((([e,t])=>{i(e)&&i(t)&&Or(e,r)&&(""!==t&&(r[t]=r[e]),delete r[e])})),ho(t,r)}if(y(e)){const r=e.filter((e=>y(e)&&e.length>0||i(e))).map((e=>{if(y(e)){if(1===e.length)return[e[0],""];if(2===e.length)return e;if(e.length>2)return e.slice(0,2);throw new Error("Unexpected error happened!")}if(i(e))return[e,""]})),o=lo(t);return r.forEach((e=>{const[t,r]=e;i(t)&&i(r)&&Or(t,o)&&(""!==r&&(o[r]=o[t]),delete o[t])})),ho(t,o)}if(i(e))return vo(yo(e),t);throw new TypeError(`"replaced" is expected to be type of String | Array | Object, but received ${e}`)})),Eo=G(2,((e,t)=>{const r=yo(e),o=yo(t);return r.every((e=>o.includes(e)))})),xo=Pe(((e,t,r)=>void 0!==r[t-1]&&e===r[t-1])),Oo=e=>Pe(((t,r,o)=>!(void 0===o[r-1]||!e.includes(t))&&t===o[r-1])),jo=e=>Pe(((t,r,o)=>void 0!==o[r-1]&&!e.includes(t)&&t===o[r-1])),Lo=Oo([""]),Ao=Oo(["/"]),So=e=>y(e)?te(Lo,Je(""))(e):i(e)?te(Ve("/"),Lo,Je(""),fr("/"),Ve(""),Ao,De)(e):void 0,_o=e=>{const t=So(e);return y(t)?t:i(t)?fr("/",t):void 0},Mo=e=>{const t=So(e);return i(t)?t:y(t)?Ve("/",t):void 0},Co=(e,t)=>Mo(e)===Mo(t),Do=(e,t)=>{const r=te(Ve("/"),Ue(dt),_o);return r(e)===r(t)},Fo=(e,t)=>eo([d,Or("pathnames"),te(y,gr("pathnames"))],e)?(t=e.pathnames,e=e.mode||"strict",Fo(e,t)):"strict"===(e=e||"strict")?Co(...t):"loose"===e?Do(...t):void 0,ko=e=>yr("?",e)?e:`?${e}`,$o=e=>yr("?",e)?e.substring(1):e,Ro=te(Ie(((e,t)=>{if(!t)return e;const[r,o]=t.split("=");return e[r]=decodeURIComponent(o),e}),{}),fr("&"),$o),No=te(Ve("&"),Re(Ve("=")),Re((([e,t])=>[e,encodeURIComponent(t)])),wr),Uo=$o,Po=te(Ro,Uo),Io=ko,Bo=te(Io,No),qo=e=>i(e)?ko(e):d(e)?Bo(e):void 0,Wo=e=>i(e)?$o(e):d(e)?No(e):void 0,Vo=e=>i(e)?Ro(e):d(e)?e:void 0,zo=({code:e,code_message:t,status:r,status_message:o,data:n})=>({code:e,code_message:t,status:r,status_message:o||"",data:n||{}}),Ho=(...e)=>e.reduce(((e,t)=>(nn(t)?e={...t}:rn(t)?e={...e,...t}:x(t)?e={...e,status_message:e.status_message||t.message,data:{error:t}}:i(t)?e={...e,status_message:t}:d(t)?(e.data=e.data||{},e={...e,data:{...e.data,...t}}):(e.data=e.data||{},e.data.response=e.data.response||[],e.data.response.push(t)),e)),{}),Jo=({code:e,code_message:t,status_message:r,data:o})=>zo({code:e,code_message:t,status:"success",status_message:r,data:o}),Go=({code:e,code_message:t,status_message:r,data:o})=>zo({code:e,code_message:t,status:"fail",status_message:r,data:o}),Qo=({code:e,code_message:t,status_message:r,data:o})=>zo({code:e,code_message:t,status:"error",status_message:r,data:o}),Zo=({code:e,code_message:t,status_message:r,data:o})=>(console.warn(`[MobiusUtils][data] makeUnknownResponse: unknown response detected, ${JSON.stringify({code:e,code_message:t,status_message:r,data:o})}`),zo({code:e,code_message:t,status:"unknown",status_message:r,data:o})),Xo=te(Jo,Ho),Ko=te(Go,Ho),Yo=te(Qo,Ho),en=te(Zo,Ho),tn=br("status"),rn=eo([d,Or("code"),Or("code_message")]),on=rn,nn=eo([d,Or("status"),Or("status_message"),Or("data")]),an=eo([nn,tn("success")]),sn=eo([nn,tn("fail")]),cn=eo([nn,tn("error")]),pn=eo([nn,tn("unknown")]),un={code:0,code_message:"SUCCESS"},fn={code:2,code_message:"FAIL"},dn={code:1,code_message:"UNDIFINED_RUNTIME_ERROR"},yn={code:3,code_message:"UNKNOWN_RESPONSE"},ln=e=>(on(e)||(e={...e,...un}),e),hn=e=>(on(e)||(e={...e,...fn}),e),mn=e=>(on(e)||(e={...e,...dn}),e),gn=e=>(on(e)||(e={...e,...yn}),e),bn=e=>{if(nn(e)){if(an(e))return ln(e);if(sn(e))return hn(e);if(cn(e))return mn(e);if(pn(e))return gn(e)}return d(e)?Jo({...un,status_message:"success response",data:{...e}}):i(e)?Go({...fn,status_message:e,data:{response:{}}}):x(e)?Qo({...dn,status_message:e.message,data:{error:e}}):Zo({...yn,status_message:"So sad, unknown response occurred ;(",data:{response:[e]}})},wn=()=>"undefined"!=typeof wx&&wx.canIUse,Tn=()=>"object"==typeof document,vn=Tn,En=()=>"undefined"!=typeof global;let xn;wn()&&(xn=wx);const On=({webFn:e=(()=>{}),nodeFn:t=(()=>{}),wxminaFn:r=(()=>{}),defaultFn:o=(()=>{})}={})=>{Tn()?e&&e():En()?t&&t():wn()?r&&r():o&&o()},jn=async({webFn:e=(()=>{}),nodeFn:t=(()=>{}),wxminaFn:r=(()=>{}),defaultFn:o=(()=>{})}={})=>{Tn()?e&&await e():En()?t&&await t():wn()?r&&await r():o&&await o()};var Ln=r(669);const An={withCredentials:!0,headers:{"Content-Type":"application/json"}},Sn=(e,t)=>{if(u(t)&&(e=t(e||{})),u(e)&&(e=e(t||{})),!d(e))throw TypeError("Config is expected to be an object, please check your config or config modifier whick should return an config object.");return e={...An,...e},new Promise(((t,r)=>{const o=()=>{Ln({...e}).then((e=>(200!==e.status&&r(new Error(`${e.status}: ${e.statusText}`)),e))).then(t).catch(r)};On({webFn:o,nodeFn:o,wxminaFn:()=>{try{xn.request({dataType:"json",responseType:"text",...e,header:{...e.headers||{}},success:t,fail:r})}catch(e){r(e)}}})})).then((t=>{if(!e.withDataExtracted)return t;if(!t.data)return Yo(new Error('There is no "data" field in request result.'));const r=t.data;if(an(r)){const t=Sr(e,"data.payload.type"),o=Sr(r,`data.${t}`);t&&o&&(r.data=o)}return r})).then((t=>(e.responseModifier||k)(t))).catch(Yo)},_n=we(Fr),Mn=_n({method:"POST"}),Cn=_n({method:"GET"}),Dn=_n({headers:{"Content-Type":"application/json"}}),Fn=_n({withCredentials:!0}),kn=_n({withCredentials:!1}),$n=_n({withDataExtracted:!0}),Rn=q(((e,t)=>r=>o=>{const n=t(r)(o),{isValid:i}=n,a=n.detail||{},{path:s,message:c}=a;return[i,i?void 0:c||"Expected a value of type `"+e+`\`${s?" for `"+s+"`":""} but received "${JSON.stringify(o)}".`]})),Nn=Rn("Boolean",(()=>e=>({isValid:n(e)}))),Un=Rn("String",(()=>e=>({isValid:i(e)}))),Pn=Rn("Number",(()=>e=>({isValid:a(e)}))),In=Rn("Array",(e=>t=>y(t)&&e?t.reduce(((t,r)=>{const[o,n]=e(r);return t.isValid=!!t.isValid&&o,t.detail.message=t.detail.message||n,t}),{isValid:!0,detail:{message:void 0}}):{isValid:y(t)})),Bn=Rn("Object",(()=>e=>({isValid:d(e)}))),qn=(e,t)=>(console.log(t(e)),t(e)[0]),Wn={get now(){return Math.round(performance.now())}},Vn=H(((e,t,r)=>`[${Wn.now}][${e}] ${t}: ${r}...`)),zn=e=>(t,r)=>console.log(e(t||""),r||""),Hn=(e,t)=>zn(Vn(e,t)),Jn=e=>{return e&&"function"==typeof e.inspect?e.inspect():"function"==typeof e?(r=e).name?r.name:r.toString():(t=e,Array.isArray(t)?`[${t.map(Jn).join(", ")}]`:function(e){switch(typeof e){case"string":return`'${e}'`;case"object":return`{${Object.keys(e).map((t=>[t,Jn(e[t])])).map((e=>e.join(": "))).join(", ")}}`;default:return String(e)}}(t));var t,r},Gn=e=>d(e)&&e.isDatar,Qn=e=>d(e)&&e.isMutator,Zn=e=>d(e)&&e.isVoid,Xn=e=>d(e)&&e.isTerminator,Kn=e=>u(e)&&e.isVacuo;class Yn{get isVoid(){return!0}}const ei=new Yn;class ti{get isTerminator(){return!0}}const ri=new ti,oi=()=>{const e=function(){};return Object.defineProperty(e,"isVacuo",{get:()=>!0}),Object.defineProperty(e,"isEmpty",{get:()=>!0}),e},ni=oi();class ii{constructor(e,t=ni,r={}){if(!c(t)&&!Qn(t)&&!Kn(t))throw new TypeError(`The 2nd parameter of Datar's constructor is expected to be type of "Mutator" | "Vacuo" | "Undefined", but received "${typeof t}".`);this._options=r,this.value=e,this.mutator=t}static of(e,t,r={}){return new ii(e,t,r)}static empty(){return new ii(ni)}get isDatar(){return!0}get isEmpty(){return Kn(this.value)}fill(e){if(!Qn(e)&&!Kn(e))throw new TypeError(`The 1st parameter of Datar's fill method is expected to be type of "Mutator" | "Vacuo", but received "${typeof e}".`);return this.mutator=e,this}fillEmpty(){return this.mutator=ni,this}fillAuto(e=ni){return this.fill(e)}run(e=ni,...t){if(!Qn(e)&&!Kn(e))throw new TypeError(`The 1st parameter of Datar's run method is expected to be type of "Mutator" | "Vacuo", but received "${typeof e}".`);return Qn(e)?e.operation:e}}const ai=e=>{if(!u(e))throw new TypeError(`"operation" is expected to be type of "Function", but received "${typeof e}".`)},si=e=>Gn(e)||Kn(e);class ci{constructor(e,t=ni,r={}){if(!c(t)&&!si(t))throw new TypeError(`The 2nd parameter of Mutator's constructor is expected to be type of "Datar" | "Vacuo" | "Undefined", but received "${typeof t}".`);ai(e),this._options=r,this.operation=e,this.datar=t}static of(e,t,r={}){return new ci(e,t,r)}static empty(){return new ci(ni)}get isMutator(){return!0}get isEmpty(){return Kn(this.operation)}static checkOperation(e){ai(e)}static isValidOpTar(e){return si(e)}static isValidOperationTarget(e){return si(e)}static lift(e,t){if(!t)throw new TypeError(`"options" is required for lift method of Mutator, but received "${t}".`);if(!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const{type:r}=t;if(!i(r))throw new TypeError(`"type" is expected to be type of "String", but received "${typeof r}".`);if("both"===r)return this.liftBoth(e);if("left"===r)return this.liftLeft(e);if("right"===r)return this.liftRight(e);throw new TypeError(`"type" is expected be one of "both" | "left" | "right", but received "${r}".`)}static liftBoth(e){return ai(e),Z(2,((t,r,...o)=>e(si(t)?t.value:t,si(r)?r.value:r,...o)))}static liftLeft(e){return ai(e),Z(2,((t,r,...o)=>e(si(t)?t.value:t,r,...o)))}static liftRight(e){return ai(e),Z(2,((t,r,...o)=>e(t,si(r)?r.value:r,...o)))}fill(e){if(!si(e))throw new TypeError(`The 1st parameter of Mutator's fill method is expected to be type of "Datar" | "Vacuo", but received "${typeof mutator}".`);return this.datar=e,this}fillEmpty(){return this.datar=ni,this}fillAuto(e=ni){return this.fill(e)}run(e=ni,...t){return this.operation(this.datar,si(e)?e:ii.of(e),...t)}}const pi=e=>d(e)&&e.isAtom;class ui{get isAtom(){return!0}pipe(...e){return re(...e)(this)}compose(...e){return te(...e)(this)}}const fi=e=>d(e)&&e.isMutation;class di extends ui{constructor(e,t={}){if(super(),!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);if(this._options=t,Qn(e))this._mutator=e;else{if(!u(e))throw new TypeError(`"operation" is expected to be type of "Mutator" | "Function", but received "${typeof e}".`);this._mutator=ci.of(e)}this._consumers=new Set}get type(){return"MutationAtom"}get isMutation(){return!0}get isEmpty(){return this._mutator.isEmpty}static of(e,t={}){return new di(e,t)}static empty(e={}){return new di(ci.empty(),e)}static ofLift(e,t={}){const{liftType:r}=t;return new di(ci.lift(e,{type:r}),{...t,isLifted:!0,origin_operation:e})}static ofLiftBoth(e,t={}){return new di(ci.liftBoth(e),{...t,isLifted:!0,origin_operation:e})}static ofLiftLeft(e,t={}){return new di(ci.liftLeft(e),{...t,isLifted:!0,origin_operation:e})}static ofLiftRight(e,t={}){return new di(ci.liftRight(e),{...t,isLifted:!0,origin_operation:e})}get mutator(){return this._mutator}get operation(){return this._options&&this._options.isLifted?this._options.origin_operation:this._mutator.operation}subscribe(e){return this._consumers.add(e),{unsubscribe:()=>this._consumers.delete(e)}}trigger(e){if(!c(e)&&!Qn(e))throw new TypeError("Mutation must be triggered with a Mutator.");const t=e||this.mutator;F(t)||this._consumers.forEach((e=>{e(t,this)}))}triggerOperation(e){return this.trigger(ci.of(e))}observe(e){if(!yi(e))throw new TypeError("Mutation can only observe a Data!");return e.subscribe(((e,t)=>{this.mutate(e,t)}))}beObservedBy(e){return e.observe(this)}mutate(e,t){let r,o=null;if(o=Gn(e)?e:yi(e)?e.datar:ii.of(e),Xn(o.value))return this;if(t){if(!yi(t))throw new TypeError(`"data" is expected to be type of "Data", but received "${typeof t}".`);r=t}else r=yi(t)?e:r;const n=ci.of(o.run(this._mutator,r)).fill(o);return this._mutator=n,this.trigger(),this}registerTrigger(e,t={}){if(!e)throw new TypeError(`"trigger" is required, but received "${e}".`);if(!u(e))throw new TypeError(`"trigger" is expected to be type of "Function", but received "${typeof e}".`);if(!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const{forceWrap:r=!1}=t;return e(((...e)=>{Qn(e[0])&&!r||(e[0]=ci.of(e[0])),this.trigger(...e)}))}}const yi=e=>d(e)&&e.isData;class li extends ui{constructor(e,t={}){if(super(),!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);this._options=t,Gn(e)?this._datar=e:this._datar=ii.of(e),this._consumers=new Set}get type(){return"DataAtom"}get isData(){return!0}get isEmpty(){return this._datar.isEmpty}static of(e,t={}){return new li(e,t)}static empty(e={}){return new li(ii.empty(),e)}get datar(){return this._datar}get value(){return this._datar.value}subscribe(e){return this._consumers.add(e),{unsubscribe:()=>this._consumers.delete(e)}}trigger(e){if(!c(e)&&!Gn(e))throw new TypeError("Data must be triggered with a Datar.");const t=e||this.datar;F(t)||this._consumers.forEach((e=>{e(t,this)}))}triggerValue(e){return this.trigger(ii.of(e))}observe(e){if(!fi(e))throw new TypeError("Data can only observe a Mutation!");return e.subscribe(((e,t)=>{this.mutate(e,t)}))}beObservedBy(e){return e.observe(this)}mutate(e,t){let r,o;if(Qn(e))r=e;else if(fi(e))r=e.mutator;else{if(!u(e))throw new TypeError(`"mutator" is expected to be type of "Mutator" | "Mutation" | "Function", but received "${typeof e}".`);r=ci.of(e)}if(t){if(!fi(t))throw new TypeError(`"mutation" is expected to be type of "Mutation", but received "${typeof t}".`);o=t}else o=fi(e)?e:o;const n=ii.of(r.run(this._datar,o)).fill(r);return Xn(n.value)||(this._datar=n,this.trigger()),this}registerTrigger(e,t={}){if(!e)throw new TypeError(`"trigger" is required, but received "${e}".`);if(!u(e))throw new TypeError(`"trigger" is expected to be type of "Function", but received "${typeof e}".`);if(!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const{forceWrap:r=!1}=t;return e(((...e)=>(Gn(e[0])&&!r||(e[0]=ii.of(e[0])),this.trigger(...e))))}}const hi=e=>d(e)&&e.isMediator;class mi{constructor(e){if(new.target===mi)throw new Error("BaseMediator can not be instantiated!");this._atom=e}get isMediator(){return!0}get atom(){return this._atom}get isAtom(){return this._atom.isAtom}get isData(){return this._atom.isData}get isMutation(){return this._atom.isMutation}get isEmpty(){return this._atom.isEmpty}get datar(){if(this.isData)return this._atom.datar;throw new TypeError('There is no "datar" property on Mutation instance.')}get value(){if(this.isData)return this._atom.value;throw new TypeError('There is no "value" property on Mutation instance.')}get mutator(){if(this.isMutation)return this._atom.mutator;throw new TypeError('There is no "mutator" property on Data instance.')}get operation(){if(this.isMutation)return this._atom.operation;throw new TypeError('There is no "operation" property on Data instance.')}subscribe(...e){return this._atom.subscribe(...e)}trigger(...e){return this._atom.trigger(...e)}triggerValue(...e){if(this.isData)return this._atom.triggerValue(...e);throw new TypeError('There is no "triggerValue" method on Mutation instance.')}triggerOperation(...e){if(this.isMutation)return this._atom.triggerOperation(...e);throw new TypeError('There is no "triggerOperation" method on Data instance.')}observe(...e){return this._atom.observe(...e)}beObservedBy(...e){return this._atom.beObservedBy(...e)}mutate(...e){return this._atom.mutate(...e)}registerTrigger(...e){return this._atom.registerTrigger(...e)}pipe(...e){return re(...e)(this)}compose(...e){return te(...e)(this)}release(){this._atom=null}}const gi=e=>d(e)&&e.isReplayMediator;class bi extends mi{constructor(e,t=1){super(e),this._history=[],this._consumers=[],this.setReplayTime(t),this._subscribeController=e.subscribe((e=>{this._history.push(e),this._setHistory()}))}get type(){return"ReplayMediator"}get isReplayMediator(){return!0}static of(e,t){if(!pi(e))throw new TypeError("ReplayMediator can apply to an Atom only.");if(gi(e))return e;let r={};if(a(t))r.replayTime=t;else{if(!d(t))throw new TypeError(`"options" argument of ReplayMediator is expected to be type of "Number" | "Object", but received ${typeof t}.`);r={...r,...t}}const{replayTime:o,autoTrigger:n=!0}=r,i=new bi(e,o);return n&&e.trigger(),i}setReplayTime(e){if(!a(e))throw new TypeError("repalyTime is expected to be a Number.");this._replayTime=Math.floor(Math.abs(e)),this._setHistory()}_setHistory(){const e=this._history.length-this._replayTime;this._history=this._history.slice(e>=0?e:0)}replayTo(e){this._history.forEach((t=>{e(t)}))}replay(){this._consumers.forEach((e=>{this.replayTo(e)}))}subscribe(e){this._consumers.push(e);const t=this._atom.subscribe(e);return this.replayTo(e),t}beObservedBy(...e){return e[0].observe(this)}release(){this._subscribeController.unsubscribe(),super.release()}}const wi=G(2,((e,t)=>bi.of(t,{replayTime:e,autoTrigger:!1}))),Ti=G(2,((e,t)=>bi.of(t,{replayTime:e,autoTrigger:!0}))),vi=e=>d(e)&&e.isTriggerMediator;class Ei extends mi{constructor(e){super(e),this._map=new WeakMap}get type(){return"TriggerMediator"}get isTriggerMediator(){return!0}static of(e){if(!pi(e))throw new TypeError("TriggerMediator can apply to an Atom only.");return new Ei(e)}get map(){return this._map}_add(e,t){return this._map.set(e,t)}_remove(e){return this._map.delete(e)}register(e,t){const r=this._atom.registerTrigger(e,t);return r&&this._add(e,r),r}get(e){return this._map.get(e)}remove(e){const t=this._map.get(e);return t&&t.cancel(),this._remove(e)}removeAll(){let e=!1;return this._map.forEach(((t,r)=>{t.cancel(),e=this._remove(r)&&e})),e}release(){this.removeAll(),super.release()}}const xi=Z(2,((e,t,r)=>[e,t.of(e,r)])),Oi=Z(1,((e,t={})=>xi(e,bi,t))),ji=Z(1,((e,t={})=>xi(e,Ei,t))),Li=(e={})=>Oi(li.empty(),e),Ai=(e={})=>Oi(di.empty(),e),Si=()=>ji(li.empty()),_i=()=>ji(di.empty()),Mi=(e={})=>{const[t,r]=Li(e);return[t,r,e]},Ci=(e={})=>{const[t,r]=Ai(e);return[t,r,e]},Di=e=>{const[t,r]=Si(),o=r.register(e);return[t,r,e,o]},Fi=e=>{const[t,r]=_i(),o=r.register(e);return[t,r,e,o]},ki=({iterable:e,handler:t=k,autoStart:r=!1,repeatable:o=!0}={})=>{if(!u(t))throw new TypeError('"handler" is expected to be a Function.');if(!C(e))throw new TypeError('"iterable" is expected to be iterable.');const n={times:0,done:!1,values:[]},i=new WeakSet,a=()=>{try{n.values=[...e],n.values.forEach((e=>{i.forEach((r=>{r(t(e))}))})),n.done=!0,n.times+=1}catch(e){}return n};return e=>(i.add(e),r&&a(),{start:()=>((o||0===n.times)&&a(),n),cancel:()=>{}})},$i=(...e)=>{let t={};if(1===e.length)t=d(e[0])&&Or("iterable",e[0])?e[0]:{iterable:e[0]};else if(e.length>1){const r=["autoStart","repeatable"];e.forEach((e=>{C(e)?t.iterable=t.iterable||e:u(e)?t.handler=t.handler||e:n(e)&&(t[r.shift()]=e)}))}return t},Ri=te(ki,$i),Ni=te(Di,Ri),Ui=te(Fi,Ri),Pi=({target:e,type:t,handler:r=k}={})=>{if(!u(r))throw new TypeError('"handler" is expected to be a Function.');if(!M(e))throw new TypeError('"target" is expected to be an instance of EventTarget.');return o=>{const n=e=>{o(r(e))};return e.addEventListener(t,n),{cancel:()=>{e.removeEventListener(t,n)}}}},Ii=(...e)=>{let r={};return 1===e.length?r=d(e[0])&&Or("target",e[0])?e[0]:{target:e[0]}:e.length>1&&e.forEach((e=>{t(e)?r.target=r.target||e:i(e)?r.type=r.type||e:u(e)&&(r.handler=r.handler||e)})),r},Bi=te(Pi,Ii),qi=te(Di,Bi),Wi=te(Fi,Bi),Vi=({handler:e=k,start:t=0,step:r=1e3,interval:o=1e3,autoStart:n=!0}={})=>{if(!u(e))throw new TypeError('"handler" is expected to be a Function.');let i=t,a=0,s=!1;const c=new WeakSet,p=()=>{s=!0;try{a=setInterval((()=>{i+=r,c.forEach((t=>{t(e(i))}))}),o)}catch(e){s=!1}return a};return e=>(c.add(e),!s&&n&&p(),{start:()=>s?a:p(),cancel:()=>{clearInterval(a)}})},zi=(...e)=>{let t={};if(1===e.length)d(e[0])&&(t=e[0]);else if(e.length>1){const r=["start","step","interval","autoStart","handler"];e.forEach((e=>{u(e)?t.handler=t.handler||e:t[r.shift()]=e}))}return t},Hi=te(Vi,zi),Ji=te(Di,Hi),Gi=te(Fi,Hi),Qi=({timeout:e,handler:t=k,autoStart:r=!0}={})=>{if(!u(t))throw new TypeError('"handler" is expected to be a Function.');if(!a(e))throw new TypeError('"timeout" is required and expected to be a Number.');let o=!1,n=0;const i=new WeakSet,s=()=>{o=!0;try{n=setTimeout((()=>{i.forEach((e=>{e(t())}))}),e)}catch(e){o=!1}return n};return e=>(i.add(e),!o&&r&&s(),{start:()=>o?n:s(),cancel:()=>{clearTimeout(n)}})},Zi=(...e)=>{let t={};return 1===e.length?d(e[0])&&(t=e[0]):e.length>1&&e.forEach((e=>{a(e)?t.timeout=Or("timeout",t)?t.timeout:e:u(e)?t.handler=Or("handler",t)?t.handler:e:n(e)&&(t.autoStart=Or("autoStart",t)?t.autoStart:e)})),t},Xi=te(Qi,Zi),Ki=te(Di,Xi),Yi=te(Fi,Xi),ea=({observable:e,handler:t=k,autoStart:r=!0})=>{if(!u(t))throw new TypeError('"handler" is expected to be a Function.');if(!D(e))throw new TypeError('"observable" is expected to be an observable object which implements the subscribe method.');let o,n=!1;const i=new WeakSet,a=()=>{try{n=!0,o=e.subscribe((e=>{i.forEach((r=>{r(t(e))}))}))}catch(e){n=!1}return o};return e=>(i.add(e),!n&&r&&a(),{start:()=>n?o:a(),cancel:()=>o.unsubscribe()})},ta=(...e)=>{let t={};return 1===e.length?d(e[0])&&(t=e[0]):e.length>1&&e.forEach((e=>{D(e)?t.observable=Or("observable",t)?t.observable:e:u(e)?t.handler=Or("handler",t)?t.handler:e:n(e)&&(t.autoStart=Or("autoStart",t)?t.autoStart:e)})),t},ra=te(ea,ta),oa=te(Di,ra),na=te(Fi,ra),ia=({agent:e,handler:t=k,autoStart:r=!0})=>{if(!u(e))throw new TypeError('"agent" is expected to be a Function.');if(!u(t))throw new TypeError('"handler" is expected to be a Function.');let o=r;return r=>{let n=(...e)=>{o&&r(t(...e))};return e(n),{start:()=>{o=!0},pause:()=>{o=!1},cancel:()=>{o=!1,n=null}}}},aa=(...e)=>{let t={};return 1===e.length?d(e[0])?t=e[0]:u(e[0])&&(t.agent=e[0]):e.length>1&&e.forEach((e=>{u(e)?t.agent?t.handler||(t.handler=e):t.agent=e:n(e)&&(t.autoStart=Or("autoStart",t)?t.autoStart:e)})),t},sa=te(ia,aa),ca=te(Di,sa),pa=te(Fi,sa),ua=()=>li.empty(),fa=()=>di.empty(),da=(e,t)=>li.of(e,t),ya=(e,t)=>t&&d(t)?di.ofLift(e,t):di.of(e),la=(e,t)=>di.ofLiftLeft(e,t),ha=(e,t)=>di.ofLiftRight(e,t),ma=(e,t)=>di.ofLiftBoth(e,t),ga={liftType:"both"},ba=Z(1,((e,t={})=>{if(!fi(e))throw new TypeError(`"mutation" is expected to be type of "Mutation", but received "${typeof e}".`);if(!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const r=li.empty(t);return r.observe(e),gi(e)?Ti(1,r):r})),wa=Z(2,((e,t,r={...ga})=>{if(!u(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!fi(t))throw new TypeError(`"mutation" is expected to be type of "Mutation", but received "${typeof t}".`);if(!d(r))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof r}".`);const o=li.empty(),n=di.ofLift(e,r),i=li.empty();return i.observe(n),n.observe(o),o.observe(t),gi(t)?Ti(1,i):i})),Ta=Z(2,((e,t,r={...ga})=>{if(!u(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!yi(t))throw new TypeError(`"data" is expected to be type of "Data", but received "${typeof t}".`);if(!d(r))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof r}".`);const o=di.ofLift(e,r),n=li.empty();return n.observe(o),o.observe(t),gi(t)?Ti(1,n):n})),va=Z(2,((e,t,r={...ga})=>{if(!u(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!pi(t))throw new TypeError(`"atom" is expected to be type of "Mutation" | "Data", but received "${typeof t}".`);if(fi(t))return wa(e,t,r);if(yi(t))return Ta(e,t,r);throw new TypeError('Unrecognized type of "Atom" received in atomToData, expected "Mutation" | "Data".')})),Ea=Z(1,((e,t={})=>{if(!yi(e))throw new TypeError(`"data" is expected to be type of "Data", but received "${typeof e}".`);if(!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const r=di.ofLiftBoth((e=>e),t);return r.observe(e),gi(e)?Ti(1,r):r})),xa=Z(2,((e,t,r={...ga})=>{if(!u(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!yi(t))throw new TypeError(`"data" is expected to be type of "Data", but received "${typeof t}".`);if(!d(r))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof r}".`);const o=di.ofLift(e,r);return o.observe(t),gi(t)?Ti(1,o):o})),Oa=Z(2,((e,t,r={...ga})=>{if(!u(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!fi(t))throw new TypeError(`"mutation" is expected to be type of "Mutation", but received "${typeof t}".`);if(!d(r))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof r}".`);const o=li.empty(),n=di.ofLift(e,r);return n.observe(o),o.observe(t),gi(t)?Ti(1,n):n})),ja=Z(2,((e,t,r={...ga})=>{if(!u(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!pi(t))throw new TypeError(`"atom" is expected to be type of "Mutation" | "Data", but received "${typeof t}".`);if(fi(t))return Oa(e,t,r);if(yi(t))return xa(e,t,r);throw new TypeError('Unrecognized type of "Atom" received in atomToMutation, expected "Mutation" | "Data".')})),La=e=>li.of(e),Aa=e=>yi(e)?e:fi(e)?ba(e):li.of(e),Sa=Z(1,((e,t={})=>{if(!y(e))throw new TypeError(`"arr" argument in createDataInArray is expected to be type of "Array", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o=r?La:Aa;return e.map(o)})),_a=Z(1,((e,t={})=>{if(!d(e))throw new TypeError(`"obj" argument in createDataInObject is expected to be type of "Objcet", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o={},n=r?La:Aa;return Object.entries(e).map((([e,t])=>{o[e]=n(t)})),o})),Ma=e=>di.of((()=>e)),Ca=e=>yi(e)?Ea(e):fi(e)?e:Qn(e)?di.of(e):u(e)?di.ofLiftBoth(e):di.of((()=>e)),Da=Z(1,((e,t={})=>{if(!y(e))throw new TypeError(`"arr" argument in createMutationInArray is expected to be type of "Array", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o=r?Ma:Ca;return e.map(o)})),Fa=Z(1,((e,t={})=>{if(!d(e))throw new TypeError(`"obj" argument in createMutationInObject is expected to be type of "Objcet", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o={},n=r?Ma:Ca;return Object.entries(e).map((([e,t])=>{o[e]=n(t)})),o})),ka=e=>li.of(e),$a=e=>pi(e)?e:Qn(e)?di.of(e):u(e)?di.ofLiftBoth(e):li.of(e),Ra=Z(1,((e,t={})=>{if(!y(e))throw new TypeError(`"arr" argument in createAtomInArray is expected to be type of "Array", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o=r?ka:$a;return e.map(o)})),Na=Z(1,((e,t={})=>{if(!d(e))throw new TypeError(`"obj" argument in createMutationInObject is expected to be type of "Objcet", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o={},n=r?ka:$a;return Object.entries(e).map((([e,t])=>{o[e]=n(t)})),o})),Ua=ie(2,"observe"),Pa=ie(2,"beObservedBy"),Ia=e=>hi(e)?Ia(e.atom):e.type,Ba=G(2,((e,t)=>!(!pi(e)||!pi(t))&&Ia(e)===Ia(t))),qa=G(2,((e,t)=>hi(e)&&hi(t)&&e.type===t.type)),Wa=(...e)=>(e.reverse().forEach(((e,t,r)=>{t>=1&&e.beObservedBy(r[t-1])})),e[e.length-1]),Va=(...e)=>(e.forEach(((e,t,r)=>{t>=1&&e.beObservedBy(r[t-1])})),e[0]),za=(e,t)=>{if(!pi(e))throw new TypeError('"upstreamAtom" argument of binaryTweenPipeAtom are expected to be type of "Mutation" or "Data".');if(!pi(t))throw new TypeError('"downstreamAtom" argument of binaryTweenPipeAtom are expected to be type of "Mutation" or "Data".');if(Ba(e,t)){let r;if(yi(e))r=di.ofLiftLeft((e=>e));else{if(!fi(e))throw new TypeError("Unexpected type of Atom detected!");r=li.empty()}return Wa(e,r,t)}return Wa(e,t)},Ha=we(za),Ja=(...e)=>{},Ga=(...e)=>{},Qa=()=>{},Za=()=>{},Xa=(...e)=>{},Ka=(...e)=>{},Ya=()=>{},es=()=>{},ts=(...e)=>{},rs=(...e)=>{},os=G(2,((e,t)=>{if(u(e))return is(e,t);if(pi(e))return ns(e,t);throw new TypeError('"pred" argument of filterT is expected to be type of "Function" or "Atom".')})),ns=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"pred" argument of dynamicFilterT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicFilterT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"pred",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={pred:!1,target:!1,index:-1},t={pred:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("pred"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in filterM, expected to be "pred" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.pred&&e.target?"pred"===o?ri:"target"===o?(e.index=e.index+1,t.pred(t.target,e.index)?t.target:ri):void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),is=G(2,((e,t)=>{if(!u(e))throw new TypeError('"pred" argument of staticFilterT is expected to be type of "Function".');return ns(Ti(1,li.of(e)),t)})),as=qi(document,"DOMContentLoaded")[0],ss=bi.of(as,{autoTrigger:!0}),cs=qi(window,"load")[0],ps=bi.of(cs,{autoTrigger:!0}),us=qi(document,"readystatechange",(()=>document.readyState))[0],fs=bi.of(us,{autoTrigger:!0});us.triggerValue(document.readyState);const ds=os((e=>"interactive"===e||"complete"===e),fs),ys=bi.of(ds,{autoTrigger:!0}),ls=os((e=>"complete"===e),fs),hs=bi.of(ls,{autoTrigger:!0}),ms=qi(window,"resize")[0],gs=bi.of(ms,{autoTrigger:!0});ms.triggerValue({type:"resize",target:window});const bs=li.of(window),ws=bi.of(bs,{autoTrigger:!0}),Ts=li.of(document),vs=bi.of(Ts,{autoTrigger:!0}),Es=(e,t=(()=>{}),r=!1)=>{const o=document.createElement("script");return o.setAttribute("type","text/javascript"),o.src=e,o.onload=(...e)=>{t(...e),r&&o.parentNode.removeChild(o)},document.head.appendChild(o),o},xs=G(3,((e,t,r)=>new CustomEvent(e,{...r||{},detail:{eventType:e,...t||{}}}))),Os=G(3,((e,t,r)=>{if(!i(e))throw new TypeError('"selector" argument of pollingToGetNode is expected to be type of "String".');if(!a(t))throw new TypeError('"interval" argument of pollingToGetNode is expected to be type of "Number".');let o,n=0;n=setInterval((()=>{o=e.includes("#")||e.includes(".")?o||document.querySelector(e):o||document.getElementById(e),o&&(clearInterval(n),r(o))}),t)})),js=new Map,Ls=(e,t)=>(t&&js.set(e,t),js.get(e)),As=(e=(e=>e))=>{let t;const[r,o,n]=ca((e=>{t=e}),(t=>e(t)));return[t,r,o,n]},Ss=(e=(e=>e))=>{const[t,r,o,n]=As(e);return[Ta((()=>t),hs),t,r,o,n]},_s=new Map;Ls("elementBasedMessageProxyMap",_s);const Ms=(e,t,r)=>{const o=_s.get(e+t);if(o)return o;let n=document.getElementById(e);if(!n){const t=document.createElement("div");t.id=e,t.style.display="none",document.body.appendChild(t),n=t}const i=new class{constructor(e,t,r){const[o]=qi(e,t),n=li.empty(),i=di.ofLiftBoth((o=>{let n,i;return d(o)?Or("detail",o)&&Or("options",o)?(n=o.detail,i=o.options):n=o:n={data:o},n.from=r,e.dispatchEvent(xs(t,n,i)),{type:t,detail:n,options:i}})),a=di.ofLiftBoth((r=>{let o,n;return d(r)?Or("detail",r)&&Or("options",r)?(o=r.detail,n=r.options):o=r:o={data:r},e.dispatchEvent(xs(t,o,n)),{type:t,detail:o,options:n}})),s=li.empty();Wa(n,i,s),Wa(a,s),this.element=e,this.type=t,this.name=r,this.innerMessageD=n,this.sender=i,this.onymousSender=i,this.anonymousSender=i,this.sendedD=s;const c=os((e=>e.detail.to===r),o);this.receiver=c,this.broadReceiver=o,this.namedReceiver=c,this.anonymousReceiver=os((e=>void 0===e.detail.from),o)}customizeReveiver(e){if(u(e))return os(e,this.broadReceiver);if(d(e))return console.warn("TODO: Object type of cond as customizeReveiver's argument, you got a broadReceiver instead."),this.broadReceiver;throw new TypeError('"cond" is expected to be a Function or an Object')}send(e){return yi(e)?this.sender.observe(e):fi(e)?this.sender.observe(ba(e)):void this.innerMessageD.triggerValue(e)}receive(e){if(fi(e))return e.observe(this.receiver);if(yi(e))return Ea(e).observe(this.receiver);if(u(e))return this.receiver.subscribe((({value:t})=>{e(t)}));throw new TypeError('"handler" is expected to be type of Mutation | Data | Function.')}receiveDetail(e){if(u(e))return this.receiver.subscribe((({value:t})=>{e(t.detail)}));if(pi(e))return ja((e=>e.detail),e).observe(this.receiver);throw new TypeError('"handler" is expected to be type of Mutation | Data | Function.')}}(n,t,r);return _s.set(e+t,i),i},Cs=new Map,Ds=(e,t)=>{if(!e)throw new TypeError('"creator" is required!');const r=new Map,o=new Map;return{getCreator:()=>e,getOptions:()=>t,isRegisteredScope:e=>!!r.get(e),releaseScope:e=>r.delete(e),releaseManager:()=>{const{isStray:r,strayFlag:o}=t;if(r){let e=!1;return Cs.forEach(((t,r)=>{e||r.flag!==o||(e=Cs.delete(r))})),e}return Cs.delete(e)},registerScope:(t,n)=>{let a,s,c;if(d(t))s=t.instance,c=t.params,a=t.scope;else{if(!i(t))throw new TypeError(`first argument of registerScope is expected to be type of "String" | "Object", but received "${typeof t}".`);a=t,d(n)?(s=n.instance,c=n.params):c=n}if(!i(a))throw new TypeError(`"scope" is required and is expected to be type of "String", but received "${typeof a}".`);if(!e&&!s)throw new TypeError('"creator" is not given, "instance" is required!');d(c)&&(c={...c,"@scopeName":a});let p=r.get(a);if(!p){p=s||(u(e)?c?y(c)?e(...c):e(c):e({"@scopeName":a}):e),r.set(a,p);const t=o.get(a);t&&(pi(p)?za(Ti(1,p),t):za(Ti(1,li.of(p)),t))}return p},getInstance:(e,t={})=>{const n=d(e)?e.scope:e;if(!i(n))throw new TypeError(`"scope" is required and is expected to be type of "String", but received "${typeof n}".`);if(d(e)?e.options?t=e.options:delete(t=Object.assign({},e)).scope:i(e)&&(t=t||{}),!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const{acceptPromise:a=!0}=t,s=r.get(n);if(s)return s;if(!a)return!1;const c=o.get(n);if(c)return c;const p=li.empty();return o.set(n,p),p},scope:function(e){return this.registerScope(e),this.getInstance(e)}}},Fs=(e,t={})=>{if(!d(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const{isStray:r=!1,strayFlag:o}=t;let n;return r?(n=Ds(e,t),Cs.set({creator:e,options:{isStray:r,strayFlag:o},flag:o},n)):(n=Cs.get(e),n||(n=Ds(e,t),Cs.set(e,n))),n},ks=e=>d(e)&&e.isFlatMediator;class $s extends mi{constructor(e,t){const r=li.empty();super(r),this._atom=r,this._origin_atom=e,this._connection=null,this._subscribeController=null,this.options=t;const{autoConnect:o}=this.options;o&&this.connect()}get type(){return"FlatMediator"}get isFlatMediator(){return!0}static of(e,t){if(!pi(e))throw new TypeError("FlatMediator can apply to an Atom only.");const{autoConnect:r=!0}=t;return new $s(e,{autoConnect:r})}connect(){if(this._origin_atom.isData){const e=di.ofLiftLeft((e=>e));this._subscribeController=this._origin_atom.subscribe((({value:t})=>{const r=this._atom.observe(e),o=e.observe(t);t.trigger(),this._connection={unsubscribe:()=>{r.unsubscribe(),o.unsubscribe()}}}))}else if(this.isMutation){const e=li.empty(),t=di.ofLiftLeft((e=>e));this._subscribeController=e.subscribe((({value:e})=>{const r=this._atom.observe(t),o=t.observe(e);e.trigger(),this._connection={unsubscribe:()=>{r.unsubscribe(),o.unsubscribe()}}})),e.observe(this._origin_atom)}}disconnect(){this._connection&&(this._connection.unsubscribe(),this._connection=null)}release(){this._subscribeController.unsubscribe(),super.release()}}const Rs=Z(1,((e,t={})=>$s.of(e,t))),Ns={liftType:"both"},Us=Z(2,((e={},t={...Ns})=>{if(!d(e)&&!u(e))throw new TypeError(`"createOptions" is expected to be type of "Object" | "Function", but received "${typeof e}".`);u(e)&&(e={prepareMidpiece:e});const{prepareTacheLevelContexts:r=(()=>({})),prepareOptions:o=(e=>e),prepareInput:n=((e,t,r)=>r),prepareMidpiece:i=(()=>di.ofLiftBoth((e=>e))),prepareOutput:a=(()=>li.empty()),connect:s=((e,[t,r,o])=>{Wa(r,o),za(t,r)})}=e,c=r();if(!d(c))throw new TypeError(`"tacheLevelContexts" is expected to be type of "Object", but received "${typeof c}".`);if(!d(t))throw new TypeError(`"tacheOptions" is expected to be type of "Object", but received "${typeof t}".`);if(t=o(t),!d(t))throw new TypeError(`The returned value of "prepareOptions" is expected to be type of "Object", but received "${typeof t}".`);return(...e)=>{const r=n(t,c,e.length>1?e:e[0]),o=i(t,c,r),p=a(t,c,o);return s(t,c,[r,o,p]),p}})),Ps=Z(3,((e,t,...r)=>{const o=e(t);return r.length>1?o(...r):o(r[0])})),Is=(e,t={...Ns})=>{if(d(e)&&e.operation&&(t=e.options?{...Ns,...e.options}:{...Ns},e=e.operation),!u(e))throw new TypeError(`"operation" is expected to be type of "Function", but received ${typeof e}.`);const{liftType:r="both"}=t;return t=>{if(!pi(t))throw new TypeError('"target" is expected to be type of "Atom".');const o=di.ofLift(e,{liftType:r}),n=li.empty();return Wa(o,n),za(t,o),n}},Bs=(...e)=>1===e.length&&d(e[0])?Ws(e[0]):1===e.length&&y(e[0])?qs(...e[0]):e.length>1?qs(...e):void 0,qs=(...e)=>(1===e.length&&y(e[0])&&(e=e[0]),e=e.map((e=>{let t,r;if(d(e)&&e.operation)r=e.options?{...Ns,...e.options}:{...Ns},t=e.operation;else{if(!u(e))throw new TypeError(`"config" is expected to be type of "Object" | "Function", but received ${typeof e}.`);r={...Ns},t=e}if(!u(t))throw new TypeError(`"operation" is expected to be type of "Function", but received ${typeof e}.`);return{operation:t,options:r}})),t=>{if(!pi(t))throw new TypeError('"target" is expected to be type of "Atom".');const r=e.map((({operation:e,options:t})=>{const{liftType:r="both"}=t;return di.ofLift(e,{liftType:r})})),o=Array.from({length:e.length}).map((()=>li.empty()));return o.forEach(((e,o)=>{Wa(r[o],e),za(t,r[o])})),o}),Ws=e=>{if(!d(e))throw new TypeError(`"configObj" is expected to be type of "Object", but received ${typeof e}.`);return e=Object.entries(e).reduce(((e,[t,r])=>{let o,n;if(d(r)&&r.operation)n=r.options?{...Ns,...r.options}:{...Ns},o=r.operation;else{if(!u(r))throw new TypeError(`"config" is expected to be type of "Object" | "Function", but received ${typeof r}.`);n={...Ns},o=r}if(!u(o))throw new TypeError(`"operation" is expected to be type of "Function", but received ${typeof r}.`);return e[t]=e[t]||{operation:o,options:n},e}),{}),t=>{if(!pi(t))throw new TypeError('"target" is expected to be type of "Atom".');const r=Object.entries(e).reduce(((e,[t,{operation:r,options:o}])=>{const{liftType:n="both"}=o;return e[t]=e[t]||di.ofLift(r,{liftType:n}),e}),{}),o=Object.entries(e).reduce(((e,[t])=>(e[t]=e[t]||li.empty(),e)),{});return Object.entries(o).forEach((([e,o])=>{Wa(r[e],o),za(t,r[e])})),o}},Vs=(e={})=>{if(!d(e))throw new TypeError(`"config" is expected to be type of "Object", but received "${typeof e}".`);const{sourcesType:t}=e;return"array"===t.toLowerCase()?zs(e):"object"===t.toLowerCase()?Hs(e):(...t)=>1===t.length&&d(t[0])?Hs(e)(t[0]):1===t.length&&y(t[0])?zs(e)(...t[0]):t.length>1?qs(e)(...t):void 0},zs=(e={})=>{if(!d(e))throw new TypeError(`"config" is expected to be type of "Object", but received ${typeof e}.`);const{numberOfSources:t,acceptNonAtom:r=!0,opCustomizeType:o="partly",opLiftType:n="both",operation:a,autoUpdateContexts:s=!0}=e;if(!i(o))throw new TypeError(`"opCustomizeType" is expected to be type of "String", but received "${typeof o}".`);if("partly"!==o.toLowerCase()&&"fully"!==o.toLowerCase())throw new TypeError(`"opCustomizeType" is expected to be "fully" | "partly", but received "${o}".`);if(void 0===a)throw new TypeError('"operation" is required when use makeArrayMSTache to make tache.');if(!u(a))throw new TypeError(`"operation" is expected to be type of "Function", but received ${typeof a}.`);const c=(...e)=>{r?e=e.map((e=>pi(e)?e:Ti(1,li.of(e)))):e.forEach((e=>{if(!pi(e))throw new TypeError(`"source" is expected to be type of "Atom", but received ${typeof e}.`)}));const t=e.length,i=Array.from({length:t}).map(((e,t)=>di.ofLiftLeft((e=>({id:t,value:e}))))),c=Array.from({length:t}).map((()=>li.empty())),p=di.ofLift((()=>{const e={numberOfSources:t,TERMINATOR:ri};if("fully"===o.toLowerCase()){const t={...e},r=a(t);if(!u(r))throw new TypeError('"operation" is expected to return a "Function" when "opCustomizeType" is specified to "fully".');return r}if("partly"===o.toLowerCase()){const r={...e,states:Array.from({length:t}),values:Array.from({length:t})};return(e,t,o,...n)=>{if(s){const{id:t,value:o}=e;r.states[t]=!0,r.values[t]=o}return a(e,t,o,r,...n)}}})(),{liftType:n}),f=li.empty();return Wa(p,f),c.forEach((e=>{Wa(e,p)})),i.forEach(((e,t)=>{Wa(e,c[t])})),e.forEach(((e,t)=>{za(e,i[t])})),f};return t?Z(t,c):(...e)=>(1===e.length&&y(e[0])&&(e=e[0]),c(...e))},Hs=(e={})=>{if(!d(e))throw new TypeError(`"config" is expected to be type of "Object", but received "${typeof e}".`);const{acceptNonAtom:t=!0,opCustomizeType:r="partly",opLiftType:o="both",operation:n,autoUpdateContexts:a=!0}=e;if(!i(r))throw new TypeError(`"opCustomizeType" is expected to be type of "String", but received "${typeof r}".`);if("partly"!==r.toLowerCase()&&"fully"!==r.toLowerCase())throw new TypeError(`"opCustomizeType" is expected to be "fully" | "partly", but received "${r}".`);if(void 0===n)throw new TypeError('"operation" is required when use makeObjectMSTache to make tache.');if(!u(n))throw new TypeError(`"operation" is expected to be type of "Function", but received "${typeof n}".`);return e=>{if(!d(e))throw new TypeError(`"sources" is expected to be type of "Object", but received "${typeof e}".`);t?e=Object.entries(e).reduce(((e,[t,r])=>(e[t]=e[t]||(pi(r)?r:Ti(1,li.of(r))),e)),{}):Object.values(e).forEach((e=>{if(!pi(e))throw new TypeError(`"source" is expected to be type of "Atom", but received "${typeof e}".`)}));const i=Object.entries(e).reduce(((e,[t])=>(e[t]=di.ofLiftLeft((e=>({key:t,value:e}))),e)),{}),s=Object.entries(e).reduce(((e,[t])=>(e[t]=li.empty(),e)),{}),c=di.ofLift((()=>{const t={keysOfSources:Object.keys(e),TERMINATOR:ri};if("fully"===r.toLowerCase()){const e={...t},r=n(e);if(!u(r))throw new TypeError('"operation" is expected to return a "Function" when "opCustomizeType" is specified to "fully".');return r}if("partly"===r.toLowerCase()){const r={...t,states:Object.keys(e).reduce(((e,t)=>(e[t]=!1,e)),{}),values:Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{})};return(e,t,o,...i)=>{if(a){const{key:t,value:o}=e;r.states[t]=!0,r.values[t]=o}return n(e,t,o,r,...i)}}})(),{liftType:o}),p=li.empty();return Wa(c,p),Object.values(s).forEach((e=>{Wa(e,c)})),Object.entries(i).forEach((([e,t])=>{Wa(t,s[e])})),Object.entries(e).forEach((([e,t])=>{za(t,i[e])})),p}},Js=()=>{throw new Error("makeMMTache to be developed.")},Gs=e=>{if(!pi(e))throw new TypeError('"target" argument of nilToVoidT is expected to be type of "Atom" only.');const t=di.ofLiftLeft((e=>lt(e)?ei:e)),r=li.empty();return Wa(t,r),za(e,t),r},Qs=()=>{},Zs=G(2,((e,t)=>pi(e)?Xs(e,t):Ks(e,t))),Xs=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"dft" argument of dynamicDefautToT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicDefautToT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"dft",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={dft:!1,target:!1},t={dft:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("dft"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in defaultM, expected to be "dft" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.dft&&e.target?"dft"===o?ri:"target"===o?Zn(t.target)?t.dft:t.target:void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),Ks=G(2,((e,t)=>Xs(Ti(1,li.of(e)),t))),Ys=G(2,((e,t)=>{if(i(e)||y(e))return tc(e,t);if(pi(e))return ec(e,t);throw new TypeError('"selector" argument of pluckT is expected to be type of "String" | "Array" | "Atom".')})),ec=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"selector" argument of dynamicPluckT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"selector" argument of dynamicPluckT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"selector",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={selector:!1,target:!1},t={selector:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("selector"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in pluckM, expected to be "selector" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.selector&&e.target?"selector"===o?ri:"target"===o?_r(t.selector,t.target):void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),tc=G(2,((e,t)=>{if(!i(e)&&!y(e))throw new TypeError('"selector" argument of staticPluckT is expected to be type of "String" | "Array".');return ec(Ti(1,li.of(e)),t)})),rc=G(2,((e,t)=>{if(u(e))return nc(e,t);if(pi(e))return oc(e,t);throw new TypeError('"fn" argument of mapT is expected to be type of "Function" or "Atom".')})),oc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"fn" argument of dynamicMapT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicMapT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"map",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={map:!1,target:!1,index:-1},t={map:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("map"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in mapM, expected to be "map" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.map&&e.target?"map"===o?ri:"target"===o?(e.index=e.index+1,t.map(t.target,e.index)):void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),nc=G(2,((e,t)=>{if(!u(e))throw new TypeError('"fn" argument of staticMapT is expected to be type of "Function".');return oc(Ti(1,li.of(e)),t)})),ic=G(2,((e,t)=>pi(e)?ac(e,t):sc(e,t))),ac=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"start" argument of dynamicStartWithT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicStartWithT is expected to be type of "Atom".');e=Ti(1,e);const r=di.ofLiftLeft((e=>({type:"start",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={start:!1,target:!1,startExpired:!1},t={start:void 0,target:void 0,targetQueue:[]};return(r,o,n)=>{const{type:i,value:a}=r;if("start"!==i&&"target"!==i)throw new TypeError(`Unexpected type of wrapped Data received in startM, expected to be "start" | "target", but received "${i}".`);return e[i]=!0,t[i]=a,"target"===i?e.startExpired?t.target:(t.targetQueue.push(a),ri):"start"===i&&e.startExpired?ri:"start"!==i||e.startExpired?void 0:(e.startExpired=!0,t.targetQueue.unshift(a),t.targetQueue.forEach((e=>{n.triggerOperation((()=>e))})),t.targetQueue.length=0,ri)}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),sc=G(2,((e,t)=>ac(Ti(1,li.of(e)),t))),cc=G(2,((e,t)=>pi(e)?pc(e,t):uc(e,t))),pc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"start" argument of dynamicEmptyStartWithT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicEmptyStartWithT is expected to be type of "Atom".');e=Ti(1,e),t=Ti(1,t);const r=di.ofLiftLeft((e=>({type:"start",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={start:!1,target:!1,startExpired:!1},t={start:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("start"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in startM, expected to be "start" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,"target"===o?t.target:"start"===o&&e.startExpired?ri:"start"!==o||e.startExpired?void 0:(e.startExpired=!0,e.target?ri:t.start)}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),uc=G(2,((e,t)=>pc(Ti(1,li.of(e)),t))),fc=G(2,((e,t)=>{if(a(e))return yc(e,t);if(pi(e))return dc(e,t);throw new TypeError('"timer" argument of debounceTimeT is expected to be type of "Number" or "Atom".')})),dc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"timer" argument of dynamicDebounceTimeT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicDebounceTimeT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"timer",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={timer:!1,target:!1,clock:0},t={timer:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("timer"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in debounceM, expected to be "timer" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.timer&&e.target?"timer"===o?ri:"target"===o?(clearTimeout(e.clock),e.clock=setTimeout((()=>{a.triggerOperation((()=>t.target))}),t.timer),ri):void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),yc=G(2,((e,t)=>{if(!a(e))throw new TypeError('"ms" argument of staticDebounceTimeT is expected to be type of "Number".');return dc(Ti(1,li.of(e)),t)})),lc=G(2,((e,t)=>{if(a(e))return mc(e,t);if(pi(e))return hc(e,t);throw new TypeError('"timer" argument of throttleTimeT is expected to be type of "Number" or "Atom".')})),hc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"timer" argument of dynamicThrottleTimeT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicThrottleTimeT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"timer",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={timer:!1,target:!1,clock:0,canEmit:!0},t={timer:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("timer"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in throttleM, expected to be "timer" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.timer&&e.target?"timer"===o?ri:"target"===o?e.canEmit?(e.canEmit=!1,e.clock=setTimeout((()=>{clearTimeout(e.clock),e.canEmit=!0}),t.timer),t.target):ri:void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),mc=G(2,((e,t)=>{if(!a(e))throw new TypeError('"ms" argument of staticThrottleTimeT is expected to be type of "Number".');return hc(Ti(1,li.of(e)),t)})),gc=G(2,((e,t)=>{if(a(e))return wc(e,t);if(pi(e))return bc(e,t);throw new TypeError('"n" argument of withHistoryT is expected to be type of "Number" or "Atom"')})),bc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"n" argument of withDynamicHistoryT is expected to be type of "Mutation" or "Data".');if(!pi(t))throw new TypeError('"target" argument of withDynamicHistoryT is expected to be type of "Mutation" or "Data".');const r=di.ofLiftLeft((e=>({type:"n",value:parseInt(e)}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={n:!1,target:!1,history:[]},t={n:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("n"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in withHistoryM, expected to be "n" | "target", but received "${o}"`);e[o]=!0,t[o]=n;const{history:i}=e;return"n"===o?(i.length=n,ri):"target"===o?(i.pop(),i.unshift(n),[...i]):void 0}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),wc=G(2,((e,t)=>{if(!a(e))throw new TypeError('"n" argument of withStaticHistoryT is expected to be type of "Number".');return bc(Ti(1,li.of(e)),t)})),Tc=gc(2),vc=re(Tc,os((e=>e[0]&&e[1]))),Ec=e=>G(2,((t,r)=>{if(!pi(t))throw new TypeError('"to" argument of switchT is expected to be type of "Atom".');if(!pi(r))throw new TypeError('"from" argument of switchT is expected to be type of "Atom".');const o=di.ofLiftLeft((e=>({type:"to",value:e}))),n=li.empty();Wa(o,n);const i=di.ofLiftLeft((e=>({type:"from",value:e}))),a=li.empty();Wa(i,a);const s=e();Wa(n,s),Wa(a,s);const c=li.empty();return Wa(s,c),za(t,o),za(r,i),c})),xc=G(2,((e,t)=>pi(e)?Oc(e,t):jc(e,t))),Oc=Ec((()=>di.ofLiftLeft((()=>{const e={from:!1,to:!1},t={from:void 0,to:void 0};return r=>{const{type:o,value:n}=r;if("from"!==o&&"to"!==o)throw new TypeError(`Unexpected type of wrapped Data received in switchM, expected to be "from" | "to", but received "${o}"`);return e[o]=!0,t[o]=n,e.from&&e.to?"to"===o?ri:"from"===o?t.to:void 0:ri}})()))),jc=G(2,((e,t)=>Oc(Ti(1,li.of(e)),t))),Lc=Ec((()=>{const e=di.ofLiftLeft((()=>{const t={from:!1,to:!1,promise:!1},r={from:void 0,to:void 0};return o=>{const{type:n,value:i}=o;if("from"!==n&&"to"!==n)throw new TypeError(`Unexpected type of wrapped Data received in switchM, expected to be "from" | "to", but received "${n}"`);return t[n]=!0,r[n]=i,"to"===n?(t.promise&&(e.triggerOperation((()=>r.to)),t.promise=!1),ri):"from"===n?t.to?r.to:(t.promise=!0,ri):void 0}})());return e})),Ac=G(2,((e,t)=>{if(u(e))return _c(e,t);if(pi(e))return Sc(e,t);throw new TypeError('"transform" argument of distinctPreviousT is expected to be type of "Number" or "Atom".')})),Sc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"transform" argument of dynamicDistinctPreviousT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicDistinctPreviousT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"transform",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={transform:!1,target:!1,previous:void 0},t={transform:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("transform"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "transform" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.transform&&e.target?"transform"===o?ri:"target"===o?t.transform(e.previous)===t.transform(t.target)?ri:(e.previous=t.target,t.target):void 0:ri}})());Wa(i,a),Wa(o,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),_c=G(2,((e,t)=>{if(!u(e))throw new TypeError('"transform" argument of staticDistinctPreviousT is expected to be type of "Function".');return Sc(Ti(1,li.of(e)),t)})),Mc=Ac((e=>e)),Cc=G(2,((e,t)=>{if(u(e))return Fc(e,t);if(pi(e))return Dc(e,t);throw new TypeError('"transform" argument of distinctEverT is expected to be type of "Number" or "Atom".')})),Dc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"transform" argument of dynamicDistinctEverT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicDistinctEverT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"transform",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={transform:!1,target:!1,history:[]},t={transform:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("transform"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in distinctM, expected to be "transform" | "target", but received "${o}".`);if(e[o]=!0,t[o]=n,!e.transform||!e.target)return ri;if("transform"===o)return ri;if("target"===o){const r=t.transform(t.target),o=e.history;return o.includes(r)?ri:(o.push(r),t.target)}}})());Wa(i,a),Wa(o,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),Fc=G(2,((e,t)=>{if(!u(e))throw new TypeError('"transform" argument of staticDistinctEverT is expected to be type of "Function".');return Dc(Ti(1,li.of(e)),t)})),kc=Cc((e=>e)),$c=G(2,((e,t)=>{if(a(e))return Nc(e,t);if(pi(e))return Rc(e,t);throw new TypeError('"n" argument of skipT is expected to be type of "Number" or "Atom".')})),Rc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"n" argument of dynamicSkipT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicSkipT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"n",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={n:!1,target:!1,index:-1,skiped:0},t={n:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("n"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "n" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.n&&e.target?"n"===o?ri:"target"===o?e.skiped<e.n?(e.skiped=e.skiped+1,ri):t.target:void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),Nc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"n" argument of staticSkipT is expected to be type of "Number".');return Rc(Ti(1,li.of(e)),t)})),Uc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"cond" argument of skipUntilT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of skipUntilT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"cond",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={cond:!1,target:!1},t={cond:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("cond"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "cond" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.cond&&e.target?"cond"===o?ri:"target"===o?t.target:void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),Pc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"cond" argument of skipWhileT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of skipWhileT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"cond",value:Boolean(e)}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={cond:!1,target:!1},t={cond:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("cond"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "cond" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.cond&&e.target?"cond"===o?ri:"target"===o?t.cond?ri:t.target:void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),Ic=G(2,((e,t)=>{if(a(e))return qc(e,t);if(pi(e))return Bc(e,t);throw new TypeError('"n" argument of takeT is expected to be type of "Number" or "Atom".')})),Bc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"n" argument of dynamicTakeT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicTakeT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"n",value:parseInt(e)}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={n:!1,target:!1,taked:0},t={n:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("n"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "n" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.n&&e.target?"n"===o?ri:"target"===o?e.taked<e.n?(e.taked=e.taked+1,t.target):ri:void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),qc=G(2,((e,t)=>Bc(Ti(1,li.of(e)),t))),Wc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"cond" argument of takeUntilT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of takeUntilT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"cond",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={cond:!1,target:!1},t={cond:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("cond"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "cond" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.cond?ri:"target"===o?t.target:void 0}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),Vc=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"cond" argument of takeWhileT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of takeWhileT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"cond",value:Boolean(e)}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={cond:!1,target:!1},t={cond:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("cond"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "cond" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.cond&&e.target?"cond"===o?ri:"target"===o?t.cond?t.target:ri:void 0:ri}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),zc=G(4,((e,t,r,o)=>{if(u(e))return Jc(e,t,r,o);if(pi(e))return Hc(e,t,r,o);throw new TypeError('"pred" argument of iifT is expected to be type of "Function" | "Atom".')})),Hc=G(4,((e,t,r,o)=>{if(!pi(e))throw new TypeError('"pred" argument of dynamicFilterT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"trueTarget" argument of dynamicFilterT is expected to be type of "Atom".');if(!pi(r))throw new TypeError('"falseTarget" argument of dynamicFilterT is expected to be type of "Atom".');if(!pi(o))throw new TypeError('"target" argument of dynamicFilterT is expected to be type of "Atom".');const n=di.ofLiftLeft((e=>({type:"pred",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((e=>({type:"trueTarget",value:e}))),s=li.empty();Wa(a,s);const c=di.ofLiftLeft((e=>({type:"falseTarget",value:e}))),p=li.empty();Wa(c,p);const u=di.ofLiftLeft((e=>({type:"target",value:e}))),f=li.empty();Wa(u,f);const d=di.ofLiftLeft((()=>{const e={pred:!1,trueTarget:!1,falseTarget:!1,target:!1,index:-1},t={pred:void 0,trueTarget:void 0,falseTarget:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("pred"!==o&&"trueTarget"!==o&&"falseTarget"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in filterM, expected to be "pred" | "trueTarget" | "falseTarget" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,e.pred&&e.target?"pred"===o||"trueTarget"===o||"falseTarget"===o?ri:"target"===o?(e.index=e.index+1,t.pred(t.target,e.index)?e.trueTarget?t.trueTarget:ri:e.falseTarget?t.falseTarget:ri):void 0:ri}})());Wa(i,d),Wa(s,d),Wa(p,d);const y=li.empty();return Wa(d,y),za(e,n),za(t,a),za(r,c),y})),Jc=G(4,((e,t,r,o)=>{if(!u(e))throw new TypeError('"pred" argument of staticIifT is expected to be type of "Function".');return Hc(Ti(1,li.of(e)),t,r,o)})),Gc=G(3,((e,t,r)=>{if(d(e)&&d(t))return Kc(e,t,r);if(y(e)&&y(t))return Qc(e,t,r);throw d(e)&&y(e)||y(e)&&d(t)?new TypeError('"preds" & "cases" argument of caseT are expected to be the same type.'):new TypeError('"preds & "cases" argument of caseT are expected to be type of "Object" | "Array".')})),Qc=G(3,((e,t,r)=>{if(!y(e))throw new TypeError('"preds" argument of arrayCaseT is expected to be type of "Array".');if(!y(t))throw new TypeError('"cases" argument of arrayCaseT is expected to be type of "Array".');if(!pi(r))throw new TypeError('"target" argument of arrayCaseT is expected to be type of "Atom".');return e.some((e=>!pi(e)))||t.some((e=>!pi(e)))?Xc(e,t,r):Zc(e,t,r)})),Zc=G(3,((e,t,r)=>{if(!y(e))throw new TypeError('"preds" argument of dynamicArrayCaseT is expected to be type of "Array".');if(!y(t))throw new TypeError('"cases" argument of dynamicArrayCaseT is expected to be type of "Array".');if(e.length!==t.length)throw new TypeError('Lengths of "preds" & "cases" argument of arrayCaseT are expected to be equal.');if(e.forEach((e=>{if(!pi(e))throw new TypeError('"pred" in "preds" argument of dynamicArrayCaseT are expected to be type of "Atom".')})),t.forEach((e=>{if(!pi(e))throw new TypeError('"case" in "cases" argument of dynamicArrayCaseT are expected to be type of "Atom".')})),!pi(r))throw new TypeError('"target" argument of arrayCaseT is expected to be type of "Atom".');const o=e.map(((e,t)=>di.ofLiftLeft((e=>({id:t,type:"pred",value:e}))))),n=t.map(((e,t)=>di.ofLiftLeft((e=>({id:t,type:"case",value:e}))))),i=di.ofLiftLeft((e=>({type:"target",value:e}))),a=e.map((()=>li.empty())),s=t.map((()=>li.empty())),c=li.empty(),p=di.ofLiftLeft((()=>{const r={pred:Array.from({length:e.length}),case:Array.from({length:t.length}),target:!1},o={pred:Array.from({length:e.length}),case:Array.from({length:t.length}),target:void 0};return e=>{const{id:t,type:n,value:i}=e;if("pred"!==n&&"case"!==n&&"target"!==n)throw new TypeError(`Unexpected type of wrapped Data received in caseM, expected to be "pred" | "case" | "target", but received "${n}"`);if("pred"!==n&&"case"!==n||(r[n][t]=!0,o[n][t]=i),"target"===n&&(r[n]=!0,o[n]=i),!r.target||r.pred.some((e=>!e)))return ri;if("pred"===n||"case"===n)return ri;if("target"===n){let e,t=!1;for(let n=0,i=o.pred.length;n<i&&!t;n++)return o.pred[n](o.target)&&(t=!0,e=r.case[n]?o.case[n]:ri),t?e:ri;return e}}})()),u=li.empty();return Wa(p,u),o.forEach(((t,r)=>{Wa(t,a[r],p),za(e[r],t)})),n.forEach(((e,r)=>{Wa(e,s[r],p),za(t[r],e)})),Wa(i,c,p),za(r,i),u})),Xc=G(3,((e,t,r)=>{if(!y(e))throw new TypeError('"preds" argument of staticArrayCaseT is expected to be type of "Array".');if(!y(t))throw new TypeError('"cases" argument of staticArrayCaseT is expected to be type of "Array".');return e.forEach(((t,r)=>{if(u(t))e[r]=Ti(1,li.of(t));else if(!pi(t))throw new TypeError('"pred" in "preds" argument of staticArrayCaseT are expected to be type of "Function" | "Atom".')})),t.forEach(((e,r)=>{pi(e)||(t[r]=Ti(1,li.of(e)))})),Zc(e,t,r)})),Kc=G(3,((e,t,r)=>{if(!d(e))throw new TypeError('"preds" argument of objectCaseT is expected to be type of  "Object".');if(!d(t))throw new TypeError('"cases" argument of objectCaseT is expected to be type of  "Object".');if(!pi(r))throw new TypeError('"target" argument of objectCaseT is expected to be type of "Atom".');return Object.values(e).some((e=>!pi(e)))||Object.values(t).some((e=>!pi(e)))?ep(e,t,r):Yc(e,t,r)})),Yc=G(3,((e,t,r)=>{if(!d(e))throw new TypeError('"preds" argument of dynamicObjectCaseT is expected to be type of "Object".');if(!d(t))throw new TypeError('"cases" argument of dynamicObjectCaseT is expected to be type of  "Object".');if(new Set([...Object.keys(e),...Object.keys(t)]).size!==Object.keys(e).length)throw new TypeError('"preds" & "cases" argument of dynamicObjectCaseT are expected to have same keys.');if(Object.values(e).forEach((e=>{if(!pi(e))throw new TypeError('"pred" in "preds" argument of dynamicObjectCaseT are expected to be type of "Atom".')})),Object.values(t).forEach((e=>{if(!pi(e))throw new TypeError('"case" in "cases" argument of dynamicObjectCaseT are expected to be type of "Atom".')})),!pi(r))throw new TypeError('"target" argument of arrayCaseT is expected to be type of "Atom".');const o=Object.entries(e).reduce(((e,[t])=>(e[t]=di.ofLiftLeft((e=>({key:t,type:"pred",value:e}))),e)),{}),n=Object.entries(t).reduce(((e,[t])=>(e[t]=di.ofLiftLeft((e=>({key:t,type:"case",value:e}))),e)),{}),i=di.ofLiftLeft((e=>({type:"target",value:e}))),a=Object.entries(e).reduce(((e,[t])=>(e[t]=li.empty(),e)),{}),s=Object.entries(t).reduce(((e,[t])=>(e[t]=li.empty(),e)),{}),c=li.empty(),p=di.ofLiftLeft((()=>{const e={pred:{},case:{},target:!1},t={pred:{},case:{},target:void 0};return r=>{const{key:o,type:n,value:i}=r;if("pred"!==n&&"case"!==n&&"target"!==n)throw new TypeError(`Unexpected type of wrapped Data received in caseM, expected to be "pred" | "case" | "target", but received "${n}".`);if("pred"!==n&&"case"!==n||(e[n][o]=!0,t[n][o]=i),"target"===n&&(e[n]=!0,t[n]=i),!e.target||Object.values(e.pred).some((e=>!e)))return ri;if("pred"===n||"case"===n)return ri;if("target"===n){let r,o=!1;const n=Object.keys(t.pred);for(let i=0,a=n.length;i<a;i++){const a=n[i];if(o)break;return t.pred[a](t.target)&&(o=!0,r=e.case[a]?t.case[a]:ri),o?r:ri}return r}}})()),u=li.empty();return Wa(p,u),Object.entries(o).forEach((([t,r])=>{Wa(r,a[t],p),za(e[t],r)})),Object.entries(n).forEach((([e,r])=>{Wa(r,s[e],p),za(t[e],r)})),Wa(i,c,p),za(r,i),u})),ep=G(3,((e,t,r)=>{if(!d(e))throw new TypeError('"preds" argument of staticObjectCaseT is expected to be type of "Object".');if(!d(t))throw new TypeError('"cases" argument of staticObjectCaseT is expected to be type of  "Object".');return Object.entries(e).forEach((([t,r])=>{if(u(r))e[t]=Ti(1,li.of(r));else if(!pi(r))throw new TypeError('"pred" in "preds" argument of staticObjectCaseT are expected to be type of "Function" | "Atom".')})),Object.entries(t).forEach((([e,r])=>{pi(r)||(t[e]=Ti(1,li.of(r)))})),Yc(e,t,r)})),tp=(...e)=>{if(pi(e[0])||y(e[0]))return rp(...e);if(d(e[0]))return op(...e);throw new TypeError("Arguments of combineT are expected to be type of Atom | [Atom] | { Atom }.")},rp=(...e)=>{let t=e[0];y(t)||(t=e);const r=t.map((e=>{if(!pi(e))throw new TypeError('Arguments of combineT are expected to be type of "Atom".');return e})),o=t.length,n=Array.from({length:o}).map(((e,t)=>di.ofLiftLeft((e=>({id:t,value:e}))))),i=Array.from({length:o}).map((()=>li.empty())),a=di.ofLiftLeft((()=>{const e=Array.from({length:o}),t=Array.from({length:o});return r=>{const{id:o,value:n}=r;return Xn(n)?ri:(e[o]=!0,t[o]=n,[...t])}})()),s=li.of(Array.from({length:o}));return Wa(a,s),i.forEach((e=>{Wa(e,a)})),n.forEach(((e,t)=>{Wa(e,i[t])})),r.forEach(((e,t)=>{za(e,n[t])})),s},op=e=>{const t=Object.entries(e).reduce(((e,[t,r])=>{if(!pi(r))throw new TypeError('Arguments of objectCombineT are expected to be type of "Atom".');return e[t]=r,e}),{}),r=Object.entries(e).reduce(((e,[t])=>(e[t]=di.ofLiftLeft((e=>({key:t,value:e}))),e)),{}),o=Object.entries(e).reduce(((e,[t])=>(e[t]=li.empty(),e)),{}),n=di.ofLiftLeft((()=>{const t=Object.keys(e).reduce(((e,t)=>(e[t]=!1,e)),{}),r=Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{});return e=>{const{key:o,value:n}=e;return Xn(n)?ri:(t[o]=!0,r[o]=n,{...r})}})()),i=li.of(Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{}));return Wa(n,i),Object.values(o).forEach((e=>{Wa(e,n)})),Object.entries(r).forEach((([e,t])=>{Wa(t,o[e])})),Object.entries(t).forEach((([e,t])=>{za(t,r[e])})),i},np=(...e)=>{if(pi(e[0])||y(e[0]))return ip(...e);if(d(e[0]))return ap(...e);throw new TypeError("Arguments of combineLatestT are expected to be type of Atom | [Atom] | { Atom }.")},ip=(...e)=>{let t=e[0];y(t)||(t=e);const r=t.map((e=>{if(!pi(e))throw new TypeError('Arguments of combineT are expected to be type of "Atom".');return e})),o=t.length,n=Array.from({length:o}).map(((e,t)=>di.ofLiftLeft((e=>({id:t,value:e}))))),i=Array.from({length:o}).map((()=>li.empty())),a=di.ofLiftLeft((()=>{const e=Array.from({length:o}),t=Array.from({length:o});return r=>{const{id:o,value:n}=r;return Xn(n)?ri:(e[o]=!0,t[o]=n,e.every((e=>e))?[...t]:ri)}})()),s=li.empty();return Wa(a,s),i.forEach((e=>{Wa(e,a)})),n.forEach(((e,t)=>{Wa(e,i[t])})),r.forEach(((e,t)=>{za(e,n[t])})),s},ap=e=>{const t=Object.entries(e).reduce(((e,[t,r])=>{if(!pi(r))throw new TypeError('Arguments of objectCombineLatestT are expected to be type of "Atom".');return e[t]=r,e}),{}),r=Object.entries(e).reduce(((e,[t])=>(e[t]=di.ofLiftLeft((e=>({key:t,value:e}))),e)),{}),o=Object.entries(e).reduce(((e,[t])=>(e[t]=li.empty(),e)),{}),n=di.ofLiftLeft((()=>{const t=Object.keys(e).reduce(((e,t)=>(e[t]=!1,e)),{}),r=Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{});return e=>{const{key:o,value:n}=e;return Xn(n)?ri:(t[o]=!0,r[o]=n,Object.values(t).every((e=>e))?{...r}:ri)}})()),i=li.empty();return Wa(n,i),Object.values(o).forEach((e=>{Wa(e,n)})),Object.entries(r).forEach((([e,t])=>{Wa(t,o[e])})),Object.entries(t).forEach((([e,t])=>{za(t,r[e])})),i},sp=(...e)=>{let t=e[0];y(t)||(t=e);const r=t.map((e=>{if(!pi(e))throw new TypeError('Arguments of mergeT are expected to be type of "Atom".');return e})),o=di.ofLiftLeft((e=>e)),n=li.empty();return Wa(o,n),r.forEach((e=>{za(e,o)})),n},cp=(...e)=>{if(pi(e[0])||y(e[0]))return pp(...e);if(d(e[0]))return up(...e);throw new TypeError("Arguments of zipLatestT are expected to be type of Atom | [Atom] | { Atom }.")},pp=(...e)=>{let t=e[0];y(t)||(t=e);const r=t.map((e=>{if(!pi(e))throw new TypeError('Arguments of arrayZipLatestT are expected to be type of "Atom".');return e})),o=Array.from({length:t.length}).map(((e,t)=>di.ofLiftLeft((e=>({id:t,value:e}))))),n=Array.from({length:t.length}).map((()=>li.empty())),i=di.ofLiftLeft((()=>{const e=Array.from({length:t.length}),r=Array.from({length:t.length});return t=>{const{id:o,value:n}=t;return e[o]=!0,r[o]=n,e.every((e=>e))&&r.every((e=>!Xn(e)))?(e.forEach(((t,r)=>{e[r]=!1})),[...r]):ri}})()),a=li.empty();return Wa(i,a),n.forEach((e=>{Wa(e,i)})),o.forEach(((e,t)=>{Wa(e,n[t])})),r.forEach(((e,t)=>{za(e,o[t])})),a},up=e=>{const t=Object.entries(e).reduce(((e,[t,r])=>{if(!pi(r))throw new TypeError('Arguments of objectZipLatestT are expected to be type of "Atom".');return e[t]=r,e}),{}),r=Object.entries(e).reduce(((e,[t])=>(e[t]=di.ofLiftLeft((e=>({key:t,value:e}))),e)),{}),o=Object.entries(e).reduce(((e,[t])=>(e[t]=li.empty(),e)),{}),n=di.ofLiftLeft((()=>{const t=Object.keys(e).reduce(((e,t)=>(e[t]=!1,e)),{}),r=Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{});return e=>{const{key:o,value:n}=e;return t[o]=!0,r[o]=n,Object.values(t).every((e=>e))&&Object.values(r).every((e=>!Xn(e)))?(Object.keys(t).forEach((e=>{t[e]=!1})),{...r}):ri}})()),i=li.empty();return Wa(n,i),Object.values(o).forEach((e=>{Wa(e,n)})),Object.entries(r).forEach((([e,t])=>{Wa(t,o[e])})),Object.entries(t).forEach((([e,t])=>{za(t,r[e])})),i},fp=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"target" argument of withLatestFromT is expected to be type of "Mutation" or "Data".');if(!pi(t))throw new TypeError('"source" argument of withLatestFromT is expected to be type of "Mutation" or "Data".');const r=di.ofLiftLeft((e=>({type:"target",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"source",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={target:!1,source:!1},t={target:void 0,source:void 0};return r=>{const{type:o,value:n}=r;if("source"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in withLatestFromM, expected to be "source" | "target", but received "${o}".`);return e[o]=!0,t[o]=n,"target"===o?ri:"source"===o?e.target?[t.source,t.target]:[t.source]:void 0}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),dp=G(2,((e,t)=>{if(u(e))return lp(e,t);if(pi(e))return yp(e,t);throw new TypeError('"effect" argument of effectT is expected to be type of "Function" or "Atom"')})),yp=G(2,((e,t)=>{if(!pi(e))throw new TypeError('"effect" argument of dynamicEffectT is expected to be type of "Atom".');if(!pi(t))throw new TypeError('"target" argument of dynamicEffectT is expected to be type of "Atom".');const r=di.ofLiftLeft((e=>({type:"effect",value:e}))),o=li.empty();Wa(r,o);const n=di.ofLiftLeft((e=>({type:"target",value:e}))),i=li.empty();Wa(n,i);const a=di.ofLiftLeft((()=>{const e={effect:!1,target:!1},t={effect:void 0,target:void 0};return r=>{const{type:o,value:n}=r;if("effect"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in effectM, expected to be "effect" | "target", but received "${o}".`);if(e[o]=!0,t[o]=n,!e.effect||!e.target)return ri;if("effect"===o)return ri;if("target"===o){let e,r=!1;const o=t.effect((e=>{a.triggerOperation((()=>e))}),t.target,(t=>{r=!0,e=t}));return r?e:o||ri}}})());Wa(o,a),Wa(i,a);const s=li.empty();return Wa(a,s),za(e,r),za(t,n),s})),lp=G(2,((e,t)=>{if(!u(e))throw new TypeError('"effect" argument of staticEffectT is expected to be type of "Function".');return yp(Ti(1,li.of(e)),t)})),hp=G(2,((e,t)=>(e(t),t))),mp=(e="",t=0)=>hp((r=>{a(e)&&(t=e,e=""),t={LOG:"log",INFO:"info",WARN:"warn",ERROR:"error",0:"log",1:"info",2:"warn",3:"error"}[t];const o={log:"#30CFCF",info:"#3030CF",warn:"#CF8030",error:"#CF3030"};return r.subscribe((({value:r})=>{let n="";try{n=JSON.stringify(r)}catch(e){}console[t](`%c ${t.toUpperCase()} %c ${e||"tapLogValueT"}: %c`+r+"%c",`background: ${o[t]}; padding: 1px; border-radius: 3px 0 0 3px; color: #FFFFFF;`,"background: #6600FF; padding: 1px; border-radius: 0 0 0 0; color: #FFFFFF;","background: #66FF00; padding: 1px 10px; border-radius: 0 3px 3px 0; color: #000000;","background: transparent; color: #00000;",r,n)})),r})),gp=(e={})=>{if(!d(e)&&!u(e))throw new TypeError(`"createOptions" is expected to be type of "Object" | "Function", but received "${typeof e}".`);u(e)&&(e={prepareSingletonLevelContexts:e});const{prepareOptions:t=(e=>e),prepareDriverLevelContexts:r=(()=>({})),prepareSingletonLevelContexts:o=(e=>({})),prepareInstance:n=((e,t,r)=>({...r}))}=e;if(!u(t))throw new TypeError(`"prepareOptions" is expected to be type of "Function", but received "${typeof t}".`);if(!u(r))throw new TypeError(`"prepareDriverLevelContexts" is expected to be type of "Function", but received "${typeof r}".`);if(!u(o))throw new TypeError(`"prepareSingletonLevelContexts" is expected to be type of "Function", but received "${typeof o}".`);if(!u(n))throw new TypeError(`"prepareInstance" is expected to be type of "Function", but received "${typeof n}".`);const i=r();if(!d(i))throw new TypeError(`"driverLevelContexts" is expected to be type of "Object", but received "${typeof i}"`);return(e={})=>{if(!d(e))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof e}".`);if(e=t(e),!d(e))throw new TypeError(`The returned value of "prepareOptions" is expected to be type of "Object", but received "${typeof e}".`);const r=o(e,i);if(!d(r))throw new TypeError(`"singletonLevelContexts" is expected to be type of "Object", but received "${typeof r}"`);const{inputs:a={},outputs:s={}}=r;if(!d(a))throw new TypeError(`"inputs" returned as singletonLevelContexts is expected to be type of "Object", but received "${typeof a}"`);if(!d(s))throw new TypeError(`"outputs" returned as singletonLevelContexts is expected to be type of "Object", but received "${typeof s}"`);return n(e,i,r)}},bp=e=>{if(!d(e))throw new TypeError(`"interfaces" is expected to be type of "Object", but received "${typeof e}"`);const{inputs:{...t}={},outputs:{...r}={}}=e;if(!d(t))throw new TypeError(`"inputs" of interfaces is expected to be type of "Object", but received "${typeof t}"`);if(!d(r))throw new TypeError(`"outputs" of interfaces is expected to be type of "Object", but received "${typeof r}"`);return Object.entries(e).forEach((([e,r])=>{"inputs"!==e&&"outputs"!==e&&(t[e]=r)})),{inputs:{...t},outputs:{...r}}},wp=(e,t)=>{const r=e=>pi(e)?Ti(1,e):Ti(1,li.of(e));if(pi(e)&&!pi(t))y(t)&&t.forEach((t=>{pi(t)&&za(r(e),t)}));else if(pi(e)&&pi(t))za(r(e),t);else if(!pi(e)&&pi(t))za(r(e),t);else if(d(e)&&d(t))Object.entries(e).forEach((([e,r])=>{t[e]&&wp(r,t[e])}));else{if(!y(e)||!y(t))throw new TypeError("The up interfaces & down interfaces are expected to be the type combinations as follows: (Atom, Any) | (Any, Atom) | (Object | Object) | (Array | Array).");e.forEach(((e,r)=>{t[r]&&wp(e,t[r])}))}},Tp=Z(3,((e,t,r)=>{const o=e(t),{inputs:{...n}={},outputs:{...i}={},...a}={...o},{inputs:{...s}={},outputs:{...c}={}}={...bp(r)};return wp(s,n),wp(i,c),{inputs:n,outputs:i,...a}})),vp={equiped:X,equip:ve}})(),o})()}));