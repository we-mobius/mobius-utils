!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("MobiusUtils",[],t):"object"==typeof exports?exports.MobiusUtils=t():e.MobiusUtils=t()}(this,(function(){return(()=>{"use strict";var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{BaseAtom:()=>wo,BaseMediator:()=>jo,Data:()=>xo,Datar:()=>ho,Either:()=>et,FlatMediator:()=>So,IO:()=>St,Identity:()=>$t,Just:()=>Lt,Left:()=>tt,Maybe:()=>xt,Mutation:()=>vo,Mutator:()=>go,Nothing:()=>jt,ReplayMediator:()=>_o,Right:()=>rt,TERMINATOR:()=>fo,Task:()=>Ut,Terminator:()=>po,TriggerMediator:()=>Ao,VACUO:()=>yo,VOID:()=>co,Vacuo:()=>uo,Void:()=>so,Z:()=>De,allPass:()=>eo,always:()=>ge,and:()=>at,anyPass:()=>to,ap:()=>zt,apply:()=>Te,applyTo:()=>ve,argPlaceholder:()=>P,arrayCaseT:()=>Da,arrayCombineLatestT:()=>Ra,arrayCombineT:()=>Ua,arrayZipLatestT:()=>za,asIs:()=>k,asIsDistinctEverT:()=>ma,asIsDistinctPreviousT:()=>ya,asNull:()=>I,asUndefined:()=>C,assign:()=>jr,assignTo:()=>Or,atomToData:()=>Ho,atomToMutation:()=>Qo,beObservedBy:()=>Ki,between:()=>Jr,binary:()=>pe,binaryHyperComposeAtom:()=>dn,binaryHyperPipeAtom:()=>yn,binaryLiftComposeAtom:()=>pn,binaryLiftPipeAtom:()=>cn,binaryTweenComposeAtom:()=>nn,binaryTweenPipeAtom:()=>on,caseT:()=>Fa,cata:()=>Ht,chain:()=>qt,combineLatestT:()=>Wa,combineT:()=>Na,complement:()=>pt,compose:()=>te,compose2:()=>Me,composeAtom:()=>rn,composeB:()=>Fe,composeL:()=>K,composeR:()=>X,concat:()=>Qe,connectInterfaces:()=>ts,constant:()=>me,converge:()=>Ae,createArrayMSTache:()=>Ln,createArraySMTache:()=>vn,createAtomInArray:()=>si,createAtomInObject:()=>ci,createDataFromEvent:()=>Mi,createDataFromFunction:()=>Gi,createDataFromInterval:()=>Si,createDataFromIterable:()=>xi,createDataFromObservable:()=>Vi,createDataFromTimeout:()=>Ui,createDataInArray:()=>Yo,createDataInObject:()=>ei,createDataOf:()=>No,createDataWithReplay:()=>mi,createDataWithReplayMediator:()=>yi,createDataWithTrigger:()=>bi,createDataWithTriggerMediator:()=>hi,createEmptyData:()=>Co,createEmptyMutation:()=>Io,createEventTrigger:()=>ji,createEventTriggerF:()=>Ai,createFunctionTrigger:()=>zi,createFunctionTriggerF:()=>Ji,createGeneralDriver:()=>Ya,createGeneralTache:()=>gn,createIntervalTrigger:()=>Fi,createIntervalTriggerF:()=>$i,createIterableTrigger:()=>Ti,createIterableTriggerF:()=>Ei,createMMTache:()=>On,createMSTache:()=>xn,createMutationFromEvent:()=>_i,createMutationFromFunction:()=>Zi,createMutationFromInterval:()=>ki,createMutationFromIterable:()=>Li,createMutationFromObservable:()=>qi,createMutationFromTimeout:()=>Pi,createMutationInArray:()=>oi,createMutationInObject:()=>ii,createMutationOf:()=>Uo,createMutationOfLB:()=>Ro,createMutationOfLL:()=>Po,createMutationOfLR:()=>Wo,createMutationWithReplay:()=>gi,createMutationWithReplayMediator:()=>di,createMutationWithTrigger:()=>wi,createMutationWithTriggerMediator:()=>li,createObjectMSTache:()=>jn,createObjectSMTache:()=>En,createObservableTrigger:()=>Wi,createObservableTriggerF:()=>Bi,createSMTache:()=>Tn,createSSTache:()=>wn,createTimeoutTrigger:()=>Ci,createTimeoutTriggerF:()=>Ni,curry:()=>H,curryN:()=>G,curryS:()=>B,dataToData:()=>zo,dataToMutation:()=>Go,dataToMutationS:()=>Jo,debounce:()=>Nr,debounceTimeT:()=>Jn,deepCopy:()=>$r,deepCopyViaJSON:()=>Dr,defaultProps:()=>Ar,defaultToT:()=>_n,distinctEverT:()=>da,distinctPreviousT:()=>pa,duplication:()=>Le,dynamicArrayCaseT:()=>$a,dynamicDebounceTimeT:()=>Gn,dynamicDefautToT:()=>Fn,dynamicDistinctEverT:()=>ha,dynamicDistinctPreviousT:()=>fa,dynamicEffectT:()=>Za,dynamicEmptyStartWithT:()=>zn,dynamicFilterT:()=>Pn,dynamicIifT:()=>Ma,dynamicMapT:()=>In,dynamicObjectCaseT:()=>Ca,dynamicPluckT:()=>Sn,dynamicSkipT:()=>ba,dynamicStartWithT:()=>Bn,dynamicSwitchT:()=>aa,dynamicTakeT:()=>xa,dynamicThrottleTimeT:()=>Kn,effectT:()=>Ga,either:()=>nt,eitherToMaybe:()=>er,emptifyObj:()=>Fr,emptyStartWithT:()=>qn,entries:()=>wr,equals:()=>gt,every:()=>Ce,filter:()=>Ue,filterFalsy:()=>Yr,filterT:()=>Un,filterTruthy:()=>Xr,flat:()=>Be,flip:()=>we,forEach:()=>Ne,formatEventTriggerCreatorFlatArgs:()=>Oi,formatFunctionTriggerCreatorFlatArgs:()=>Hi,formatIntervalTriggerCreatorFlatArgs:()=>Di,formatIterableTriggerCreatorFlatArgs:()=>vi,formatObservableTriggerCreatorFlatArgs:()=>Ri,formatTimeoutTriggerCreatorFlatArgs:()=>Ii,get:()=>Mr,getAtomType:()=>Xi,getByPath:()=>_r,hardDeepMerge:()=>Sr,hasOwnProperty:()=>Lr,humanize:()=>or,identity:()=>he,ifElse:()=>wt,iif:()=>Et,iifT:()=>Aa,iife:()=>Cr,includes:()=>ke,indexOf:()=>fr,internalCurry:()=>z,internalCurryN:()=>J,internalLooseCurry:()=>V,internalLooseCurryN:()=>Z,intersection:()=>Xe,invoker:()=>ne,io:()=>kt,isAllSpace:()=>hr,isApplicative:()=>Rt,isArgPlaceholder:()=>W,isArray:()=>d,isAsyncFn:()=>T,isAsyncGeneratorFunction:()=>E,isAtom:()=>bo,isBoolean:()=>i,isData:()=>Eo,isDatar:()=>ro,isDate:()=>u,isDefined:()=>r,isDocument:()=>_,isEmailAddress:()=>Kr,isEmpty:()=>S,isEmptyArr:()=>j,isEmptyObj:()=>O,isEmptyStr:()=>L,isError:()=>x,isEven:()=>Rr,isEventTarget:()=>F,isFalse:()=>ut,isFalsy:()=>dt,isFlatMediator:()=>$o,isFunction:()=>f,isFunctor:()=>Pt,isGeneralObject:()=>o,isGeneratorFunction:()=>v,isIterable:()=>D,isMap:()=>h,isMediator:()=>Lo,isMonad:()=>Wt,isMonoid:()=>Bt,isMutation:()=>To,isMutator:()=>oo,isNil:()=>ht,isNotNil:()=>lt,isNull:()=>p,isNumber:()=>a,isObject:()=>y,isObservable:()=>$,isOdd:()=>Br,isOutDated:()=>A,isPhoneNum:()=>Gr,isPromise:()=>w,isQQId:()=>Qr,isRegExp:()=>b,isReplayMediator:()=>Mo,isSameTypeOfAtom:()=>Yi,isSameTypeOfMediator:()=>en,isSet:()=>m,isStartWith:()=>dr,isString:()=>n,isSymbol:()=>s,isTelNum:()=>Zr,isTerminator:()=>no,isTriggerMediator:()=>Oo,isTrue:()=>ft,isTruthy:()=>yt,isUndefined:()=>c,isVacuo:()=>ao,isVoid:()=>io,isWeakMap:()=>l,isWeakSet:()=>g,isWindow:()=>M,join:()=>qe,just:()=>Ot,keys:()=>Tr,kite:()=>be,left:()=>ot,lift:()=>Gt,liftA2:()=>Zt,liftA3:()=>Qt,liftA4:()=>Kt,liftA5:()=>Xt,liftN:()=>Jt,looseBinary:()=>fe,looseCurry:()=>q,looseCurryN:()=>Q,looseCurryS:()=>R,looseEquals:()=>bt,looseInvoker:()=>ae,looseNAry:()=>ce,looseUnary:()=>ye,map:()=>Ie,mapT:()=>Cn,maxOf:()=>Hr,maxTo:()=>Vr,maybe:()=>Dt,maybeToEither:()=>Yt,memorize:()=>oe,mergeT:()=>Va,minOf:()=>zr,minTo:()=>qr,mutationToData:()=>qo,mutationToDataS:()=>Vo,mutationToMutation:()=>Zo,nAry:()=>se,nAryHyperComposeAtom:()=>ln,nAryHyperPipeAtom:()=>hn,nAryLiftComposeAtom:()=>un,nAryLiftPipeAtom:()=>fn,nAryTweenComposeAtom:()=>sn,nAryTweenPipeAtom:()=>an,nilToVoidT:()=>An,noop:()=>N,not:()=>ct,nothing:()=>At,objectCaseT:()=>ka,objectCombineLatestT:()=>Ba,objectCombineT:()=>Pa,objectZipLatestT:()=>Ha,observe:()=>Qi,of:()=>Vt,omega:()=>le,once:()=>Ir,or:()=>st,orElse:()=>_t,orJust:()=>Ft,packing:()=>Wr,pairwiseT:()=>ra,partitionT:()=>Mn,perform:()=>It,performUnsafeIO:()=>Nt,pipe:()=>re,pipeAtom:()=>tn,pipeL:()=>Y,pipeR:()=>ee,pluckT:()=>$n,pop:()=>He,promiseSwitchT:()=>ca,prop:()=>gr,propEq:()=>br,psi:()=>_e,push:()=>ze,randomString:()=>mr,reduce:()=>We,reject:()=>Pe,replace:()=>yr,replayWithLatest:()=>Do,replayWithoutLatest:()=>Fo,right:()=>it,run:()=>Ct,safe:()=>Mt,semantic:()=>os,shift:()=>Ge,shuffle:()=>Se,skipT:()=>ga,skipUntilT:()=>Ta,skipWhileT:()=>va,slice:()=>Ve,smartDeepMerge:()=>kr,some:()=>Re,split:()=>ur,startWithT:()=>Rn,staticArrayCaseT:()=>Sa,staticDebounceTimeT:()=>Zn,staticDefaultToT:()=>Dn,staticDistinctEverT:()=>la,staticDistinctPreviousT:()=>ua,staticEffectT:()=>Qa,staticEmptyStartWithT:()=>Hn,staticFilterT:()=>Wn,staticIifT:()=>_a,staticMapT:()=>Nn,staticObjectCaseT:()=>Ia,staticPluckT:()=>kn,staticSkipT:()=>wa,staticStartWithT:()=>Vn,staticSwitchT:()=>sa,staticTakeT:()=>La,staticThrottleTimeT:()=>Xn,strictEquals:()=>mt,substitution:()=>je,substitution2:()=>Oe,switchT:()=>na,takeT:()=>Ea,takeUntilT:()=>ja,takeWhileT:()=>Oa,tap:()=>de,tapT:()=>Ka,tapValueT:()=>Xa,throttle:()=>Ur,throttleTime:()=>Pr,throttleTimeT:()=>Qn,thrush:()=>Ee,toArray:()=>$e,toLowerCase:()=>nr,toString:()=>ir,toUpperCase:()=>ar,trim:()=>sr,trimLeft:()=>pr,trimRight:()=>cr,truthyKeys:()=>Er,truthyPairwiseT:()=>oa,truthyValues:()=>xr,unary:()=>ue,union:()=>Ke,unique:()=>Ze,unless:()=>vt,unshift:()=>Je,useGeneralDriver:()=>rs,useGeneralTache:()=>bn,values:()=>vr,vireo:()=>xe,when:()=>Tt,withDynamicHistoryT:()=>ea,withHistoryT:()=>Yn,withLatestFromT:()=>Ja,withMediator:()=>pi,withReplayMediator:()=>fi,withStaticHistoryT:()=>ta,withTriggerMediator:()=>ui,withValueFlatted:()=>ko,zipLatestT:()=>qa});const r=e=>void 0!==e,o=e=>"object"==typeof e,i=e=>"[object Boolean]"===Object.prototype.toString.call(e),n=e=>"[object String]"===Object.prototype.toString.call(e),a=e=>"[object Number]"===Object.prototype.toString.call(e),s=e=>"[object Symbol]"===Object.prototype.toString.call(e),c=e=>"[object Undefined]"===Object.prototype.toString.call(e),p=e=>"[object Null]"===Object.prototype.toString.call(e),f=e=>e&&"[object Function]"===Object.prototype.toString.call(e),u=e=>e&&"[object Date]"===Object.prototype.toString.call(new Date(e))&&!!new Date(e).getTime(),y=e=>"[object Object]"===Object.prototype.toString.call(e),d=e=>"[object Array]"===Object.prototype.toString.call(e),h=e=>"[object Map]"===Object.prototype.toString.call(e),l=e=>"[object WeakMap]"===Object.prototype.toString.call(e),m=e=>"[object Set]"===Object.prototype.toString.call(e),g=e=>"[object WeakSet]"===Object.prototype.toString.call(e),b=e=>"[object RegExp]"===Object.prototype.toString.call(e),w=e=>"[object Promise]"===Object.prototype.toString.call(e),T=e=>"[object AsyncFunction]"===Object.prototype.toString.call(e),v=e=>"[object GeneratorFunction]"===Object.prototype.toString.call(e),E=e=>"[object AsyncGeneratorFunction]"===Object.prototype.toString.call(e),x=e=>"[object Error]"===Object.prototype.toString.call(e),L=e=>n(e)&&0===e.length,j=e=>d(e)&&0===e.length,O=e=>y(e)&&0===Object.keys(e).length,A=e=>u(e)&&new Date(e).getTime()<(new Date).getTime(),M=e=>"[object Window]"===Object.prototype.toString.call(e),_=e=>"[object HTMLDocument]"===Object.prototype.toString.call(document),F=e=>e instanceof EventTarget,D=e=>"object Function"===Object.prototype.toString.call(e[Symbol.iterator]),$=e=>y(e)&&(e.isObservable||f(e.subscribe)),S=e=>p(e)||c(e)||L(e)||j(e)||O(e)||y(e)&&e.isEmpty,k=e=>e,C=e=>{},I=e=>null,N=e=>{},U=e=>te((e=>!e),e),P={"@@functional/placeholder":!0,isArgPlaceholder:!0},W=e=>y(e)&&Object.prototype.hasOwnProperty.call(e,"isArgPlaceholder")&&e.isArgPlaceholder,R=(e,...t)=>t.length>=e.length?e(...t):(...r)=>R(e,...t,...r),B=(e,...t)=>{const r=e.length;return t.length>=r?e(...t.slice(0,r)):(...r)=>B(e,...t,...r)},V=(e,t,...r)=>{let o=t||[];o=o.map((e=>W(e)&&r.length>0?r.shift():e)),o=o.concat(r);const i=e.length;return o.slice(0,i).filter(U(W)).length>=i?e(...o):(...t)=>V(e,o,...t)},q=(e,...t)=>V(e,[],...t),z=(e,t,...r)=>{let o=t||[];o=o.map((e=>W(e)&&r.length>0?r.shift():e)),o=o.concat(r);const i=e.length,n=o.slice(0,i);return n.filter(U(W)).length>=i?e(...n):(...t)=>z(e,n,...t)},H=(e,...t)=>z(e,[],...t),J=(e,t,r,...o)=>{let i=r||[];i=i.map((e=>W(e)&&o.length>0?o.shift():e)),i=i.concat(o);const n=i.slice(0,e);return n.filter(U(W)).length>=e?t(...n):(...r)=>J(e,t,n,...r)},G=(e,t,...r)=>J(e,t,[],...r),Z=(e,t,r,...o)=>{let i=r||[];return i=i.map((e=>W(e)&&o.length>0?o.shift():e)),i=i.concat(o),i.slice(0,e).filter(U(W)).length>=e?t(...i):(...r)=>Z(e,t,i,...r)},Q=(e,t,...r)=>Z(e,t,[],...r),K=(...e)=>e.reduce(((e,t)=>(...r)=>t(e(...r))),e.shift()||k),X=(...e)=>K(...e.reverse()),Y=X,ee=K,te=X,re=K,oe=(e,t)=>{const r={};return t=t||((...e)=>JSON.stringify(e)),(...o)=>{const i=t(o);return r[i]||(r[i]=e.apply(void 0,o)),r[i]}},ie=e=>(t,r)=>e(t,((...e)=>{const t=e[e.length-1];if(!t[r])throw Error(`Can not find "${r}" method in target.'`);if(!f(t[r]))throw Error(`"${r}" property in target is not a function.`);return t[r](...e.slice(0,e.length-1))})),ne=ie(G),ae=ie(Q),se=H(((e,t)=>G(e,t))),ce=H(((e,t)=>Q(e,t))),pe=e=>H(((t,r)=>e(t,r))),fe=e=>q(((t,r,...o)=>e(t,r,...o))),ue=e=>t=>e(t),ye=e=>(t,...r)=>e(t,...r),de=e=>(...t)=>(e(...t),t[0]),he=e=>e,le=e=>e(e),me=e=>()=>e,ge=me,be=e=>e=>e,we=G(3,((e,t,r)=>H(e)(r)(t))),Te=G(2,((e,t)=>e(t))),ve=G(2,((e,t)=>t(e))),Ee=ve,xe=G(3,((e,t,r)=>H(r)(e)(t))),Le=G(2,((e,t)=>H(e)(t)(t))),je=G(3,((e,t,r)=>H(e)(r)(t(r)))),Oe=G(3,((e,t,r)=>H(e)(t(r))(r))),Ae=G(4,((e,t,r,o)=>H(e)(t(o))(r(o)))),Me=G(5,((e,t,r,o,i)=>H(e)(t(o))(r(i)))),_e=G(4,((e,t,r,o)=>H(e)(t(r))(t(o)))),Fe=G(3,((e,t,r)=>e(t(r)))),De=e=>{return t=t=>e(((...e)=>t(t)(...e))),e(((...e)=>t(t)(...e)));var t},$e=e=>[...e],Se=e=>{for(let t=(e=[].concat(e)).length;t;t--){const r=Math.floor(Math.random()*t);[e[t-1],e[r]]=[e[r],e[t-1]]}return e},ke=ne(2,"includes"),Ce=ne(2,"every"),Ie=ne(2,"map"),Ne=ne(2,"forEach"),Ue=ne(2,"filter"),Pe=H(((e,t)=>Ue(((...t)=>!e(...t)),t))),We=ne(3,"reduce"),Re=ne(2,"some"),Be=ne(1,"flat"),Ve=ne(3,"slice"),qe=ne(2,"join"),ze=H(((e,t)=>((t=[...t]).push(e),t))),He=e=>((e=[...e]).pop(),e),Je=H(((e,t)=>((t=[...t]).unshift(e),t))),Ge=e=>((e=[...e]).shift(),e),Ze=e=>[...new Set(e)],Qe=ne(2,"concat"),Ke=G(2,te(Ze,we(Qe))),Xe=H(((e,t)=>{const r=((e,t)=>e.length>t.length?e:t)(e,t),o=((e,t)=>e.length>t.length?t:e)(e,t);return Ze(Ue(we(ke)(r),o))})),Ye=e=>{return e&&"function"==typeof e.inspect?e.inspect():"function"==typeof e?(r=e).name?r.name:r.toString():(t=e,Array.isArray(t)?`[${t.map(Ye).join(", ")}]`:function(e){switch(typeof e){case"string":return`'${e}'`;case"object":return`{${Object.keys(e).map((t=>[t,Ye(e[t])])).map((e=>e.join(": "))).join(", ")}}`;default:return String(e)}}(t));var t,r};class et{constructor(e){this._value=e}get value(){return this._value}static of(e){return new rt(e)}static right(e){return new rt(e)}static left(e){return new tt(e)}}class tt extends et{get isLeft(){return!0}get isRight(){return!1}static of(e){throw new Error("`of` called on class Left (value) instead of Either (type)")}inspect(){return`Left(${Ye(this._value)})`}map(){return this}join(){return this}chain(){return this}ap(){return this}cata({Left:e,Right:t}){return e(this._value)}sequence(e){return e(this)}traverse(e,t){return e(this)}}class rt extends et{get isLeft(){return!1}get isRight(){return!0}static of(e){throw new Error("`of` called on class Right (value) instead of Either (type)")}inspect(){return`Right(${Ye(this._value)})`}map(e){return et.of(e(this._value))}join(){return this._value}chain(e){return e(this._value)}ap(e){return this.map(e._value)}cata({Left:e,Right:t}){return t(this._value)}sequence(e){return this.traverse(e,he)}traverse(e,t){t(this._value).map(et.of)}}const ot=e=>new tt(e),it=e=>new rt(e),nt=H(((e,t,r)=>r.isLeft?e(r.value):t(r.value))),at=H(((e,t)=>!!e&&!!t)),st=H(((e,t)=>!!e||!!t)),ct=e=>!e,pt=e=>te(ct,e),ft=e=>!0===e,ut=e=>!1===e,yt=e=>1==!!e,dt=e=>0==!!e,ht=e=>null==e,lt=pt(ht),mt=H(((e,t)=>e===t)),gt=mt,bt=H(((e,t)=>e==t)),wt=H(((e,t,r,o)=>e(o)?t(o):r(o))),Tt=H(((e,t,r)=>e(r)?t(r):r)),vt=H(((e,t,r)=>e(r)?r:t(r))),Et=H(((e,t,r)=>e?t:r));class xt{static of(e){return xt.just(e)}static just(e){return new Lt(e)}static nothing(){return new jt}static fromNullable(e){return p(e)?xt.nothing():xt.just(e)}static fromUndefinedable(e){return c(e)?xt.nothing():xt.just(e)}static fromFalsyable(e){return dt(e)?xt.nothing():xt.just(e)}static fromNilable(e){return ht(e)?xt.nothing():xt.just(e)}static fromEmptyable(e){return S(e)?xt.nothing():xt.just(e)}get isNothing(){return!1}get isJust(){return!1}get isMaybe(){return!0}}class Lt extends xt{constructor(e){super(),this._value=e}get value(){return this._value}get isJust(){return!0}get isNothing(){return!1}inspect(){return`Maybe.Just(${Ye(this._value)})`}map(e){return xt.just(e(this._value))}join(){return this._value}chain(e){return e(this._value)}ap(e){return this.map(e._value)}orJust(){return this}orElse(){return this}filter(e){return e(this._value)?this:xt.nothing()}cata({Just:e,Nothing:t}){return e(this._value)}}class jt extends xt{get value(){throw new TypeError("Can't extract the value of a Nothing.")}get isNothing(){return!0}get isJust(){return!1}inspect(){return"Maybe.Nothing"}map(e){return this}join(){return this}chain(e){return this}ap(e){return this}orJust(e){return xt.of(e)}orElse(e){return e}filter(){return this}cata({Just:e,Nothing:t}){return t()}}const Ot=e=>new Lt(e),At=()=>new jt,Mt=H(((e,t)=>e(t)?Ot(t):At())),_t=ne(2,"orElse"),Ft=ne(2,"orJust"),Dt=H(((e,t,r)=>r.isNothing?e:t(r.value)));class $t{constructor(e){this._value=e}of(e){return new $t(e)}get value(){return this._value}get isIdentity(){return!0}inspect(){return`Identity(${Ye(this._value)})`}map(e){return $t.of(e(this._value))}join(){return this._value}chain(e){return e(this._value)}sequence(e){return this.traverse(e,he)}traverse(e,t){return t(this._value).map($t.of)}}class St{constructor(e){if(!f(e))throw new Error("IO requires a function.");this._value=e}static of(e){return new St(e)}static const(e){return new St(me(e))}get isIO(){return!0}inspect(){return`IO(${Ye(this._value)})`}run(...e){return this._value(...e)}perform(...e){return this._value(...e)}performUnsafeIO(...e){return this._value(...e)}map(e){return new St(te(e,this._value))}join(){return new St((()=>this.performUnsafeIO().performUnsafeIO()))}chain(e){return this.map(e).join()}ap(e){return this.chain(e._value)}}const kt=e=>new St(e),Ct=Q(1,((e,...t)=>e.run(...t))),It=Q(1,((e,...t)=>e.perform(...t))),Nt=Q(1,((e,...t)=>e.performUnsafeIO(...t)));class Ut{constructor(e){this._value=e}static of(e){return new Ut((({reject:t,resolve:r})=>r(e)))}get isTask(){return!0}inspect(){return`Task(${Ye(this._value)})`}fork({reject:e,resolve:t}){return this._value({reject:e,resolve:t})}map(e){return new Ut((({reject:t,resolve:r})=>this.fork({reject:t,resolve:t=>r(e(t))})))}join(){return new Ut((({reject:e,resolve:t})=>this.fork({reject:e,resolve:r=>r.fork({reject:e,resolve:e=>t(e)})})))}chain(e){return new Ut((({reject:t,resolve:r})=>this.fork({reject:t,resolve:o=>e(o).fork({reject:t,resolve:r})})))}ap(e){return this.map(e._value)}}const Pt=e=>{},Wt=e=>{},Rt=e=>{},Bt=e=>{},Vt=ne(2,"of"),qt=ne(2,"chain"),zt=ne(2,"ap"),Ht=ne(1,"cata"),Jt=H(((e,t)=>{const r=G(e,t);return G(e,((...e)=>We(zt,e[0].map(r),e.slice(1))))})),Gt=e=>Jt(e.length,e),Zt=Jt(2),Qt=Jt(3),Kt=Jt(4),Xt=Jt(5),Yt=(e,t)=>t.isNothing?et.left(e):t.chain(et.right),er=e=>e.isLeft?xt.nothing():e.chain(xt.just),tr={year:"年",month:"月",week:"周",day:"天",hour:"小时",minute:"分钟",second:"秒",millisecond:"毫秒"},rr={year:315576e5,month:26298e5,week:6048e5,day:864e5,hour:36e5,minute:6e4,second:1e3,millisecond:1},or=e=>{let t="";const r=+new Date-e;for(const e in rr)if(r>=rr[e]){t=`${Math.floor(r/rr[e])} ${tr[e]}前`;break}return t||"刚刚"},ir=ne(1,"toString"),nr=ne(1,"toLowerCase"),ar=ne(1,"toUpperCase"),sr=ne(1,"trim"),cr=ne(1,"trimRight"),pr=ne(1,"trimLeft"),fr=ne(2,"indexOf"),ur=ne(2,"split"),yr=ne(3,"replace"),dr=H(((e,t)=>0===fr(e,t))),hr=e=>!!sr(e),lr={},mr=(e,t)=>{let r="";t=t||"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";for(let o=e;o>0;--o)r+=t[Math.floor(Math.random()*t.length)];lr[e]=lr[e]||[];const o=lr[e];return o.includes(r)?mr():(o.push(r),r)},gr=H(((e,t)=>t[e])),br=H(((e,t,r)=>r[e]===t)),wr=Object.entries,Tr=Object.keys,vr=Object.values,Er=e=>wr(e).filter((([e,t])=>!!t)).map((([e,t])=>e)),xr=e=>wr(e).filter((([e,t])=>!!t)).map((([e,t])=>t)),Lr=H(((e,t)=>Object.prototype.hasOwnProperty.call(t,e))),jr=G(2,((e,t)=>t.assign(e))),Or=G(2,((e,t)=>e.assign(t))),Ar=jr,Mr=H(((e,t)=>{const r=te(Ue(yt),ur(/[,[/\].]+?/),yr(/['|"]/g,""));return We(((e,t)=>ht(e)?e:e[t]),e)(r(t))})),_r=H(((e,t)=>{const r=te(Ue(yt),ur(/[,./[\]\\]/g),yr(/['|"]/g,""));return We(((e,t)=>ht(e)?e:e[t]),t)(r(e))})),Fr=e=>{for(const t in e)y(e[t])?Fr(e[t]):delete e[t];return e},Dr=e=>JSON.parse(JSON.stringify(e)),$r=e=>{if(!y(e))return e;const t=d(e)?[]:{};for(const r in e)y(e[r])?t[r]=$r(e[r]):t[r]=e[r];return t},Sr=H(((e,t)=>y(e)&&y(t)?(Object.keys(t).forEach((r=>{const o=e[r],i=t[r];d(o)&&d(i)?e[r]=$r(i):y(o)&&y(i)?e[r]=Sr(o,i):e[r]=i})),e):e)),kr=(e,t)=>y(e)&&y(t)?(Object.keys(t).forEach((r=>{const o=e[r],i=t[r];d(o)&&d(i)?e[r]=o.concat(i):y(o)&&y(i)?e[r]=kr(o,i):e[r]=i})),e):e,Cr=(e,...t)=>e(...t),Ir=e=>{let t,r;return(...o)=>(t||(t=!0,r=e(...o)),r)},Nr=(e,t)=>{let r,o=[];return()=>(clearTimeout(r),r=setTimeout((async()=>{const t=await e();o.forEach((e=>{e(t)})),o=[]}),t),new Promise((e=>{o.push(e)})))},Ur=e=>{let t=!1,r=[];return()=>(t||(t=!0,Promise.resolve(e()).then((e=>{r.forEach((t=>{t(e)})),r=[],t=!1}))),new Promise((e=>{r.push(e)})))},Pr=(e,t)=>{let r=!1,o=[];return()=>(r||(r=!0,Promise.resolve(e()).then((e=>{o.forEach((t=>{t(e)})),o=[]})),setTimeout((()=>{r=!1}),t)),new Promise((e=>{o.push(e)})))},Wr=(e,t)=>{let r,o=[],i={};return n=>(clearTimeout(r),i=Sr(i,n),r=setTimeout((async()=>{const t=await e(i);o.forEach((e=>{e(t)})),o=[]}),t),new Promise((e=>{o.push(e)})))},Rr=e=>e%2==0,Br=e=>e%2!=0,Vr=G(2,((e,t)=>t>e?e:t)),qr=G(2,((e,t)=>t<e?e:t)),zr=G(2,((e,t)=>e<t?e:t)),Hr=G(2,((e,t)=>e>t?e:t)),Jr=G(3,((e,t,r)=>{const o=zr(e,t),i=Hr(e,t);return r<o?o:r>i?i:r})),Gr=e=>/^1[3-9]\d{9}$/.test(e),Zr=e=>/^(\(\d{3,4}\)|\d{3,4}-|\s)?\d{7,14}$/.test(e),Qr=e=>/^[1-9][0-9]{4,10}$/.test(e),Kr=e=>/^([A-Za-z0-9_\-.])+@([A-Za-z0-9_\-.])+\.([A-Za-z]{2,4})$/.test(e),Xr=Ue(yt),Yr=Ue(dt),eo=H(((e,t)=>Ce(ve(t),e))),to=H(((e,t)=>Re(ve(t),e))),ro=e=>y(e)&&e.isDatar,oo=e=>y(e)&&e.isMutator,io=e=>y(e)&&e.isVoid,no=e=>y(e)&&e.isTerminator,ao=e=>f(e)&&e.isVacuo;class so{get isVoid(){return!0}}const co=new so;class po{get isTerminator(){return!0}}const fo=new po,uo=()=>{const e=function(){};return Object.defineProperty(e,"isVacuo",{get:()=>!0}),Object.defineProperty(e,"isEmpty",{get:()=>!0}),e},yo=uo();class ho{constructor(e,t=yo,r={}){if(!c(t)&&!oo(t)&&!ao(t))throw new TypeError(`The 2nd parameter of Datar's constructor is expected to be type of "Mutator" | "Vacuo" | "Undefined", but received "${typeof t}".`);this._options=r,this.value=e,this.mutator=t}static of(e,t,r={}){return new ho(e,t,r)}static empty(){return new ho(yo)}get isDatar(){return!0}get isEmpty(){return ao(this.value)}fill(e){if(!oo(e)&&!ao(e))throw new TypeError(`The 1st parameter of Datar's fill method is expected to be type of "Mutator" | "Vacuo", but received "${typeof e}".`);return this.mutator=e,this}fillEmpty(){return this.mutator=yo,this}fillAuto(e=yo){return this.fill(e)}run(e=yo,...t){if(!oo(e)&&!ao(e))throw new TypeError(`The 1st parameter of Datar's run method is expected to be type of "Mutator" | "Vacuo", but received "${typeof e}".`);return oo(e)?e.operation:e}}const lo=e=>{if(!f(e))throw new TypeError(`"operation" is expected to be type of "Function", but received "${typeof e}".`)},mo=e=>ro(e)||ao(e);class go{constructor(e,t=yo,r={}){if(!c(t)&&!mo(t))throw new TypeError(`The 2nd parameter of Mutator's constructor is expected to be type of "Datar" | "Vacuo" | "Undefined", but received "${typeof t}".`);lo(e),this._options=r,this.operation=e,this.datar=t}static of(e,t,r={}){return new go(e,t,r)}static empty(){return new go(yo)}get isMutator(){return!0}get isEmpty(){return ao(this.operation)}static checkOperation(e){lo(e)}static isValidOpTar(e){return mo(e)}static isValidOperationTarget(e){return mo(e)}static lift(e,t){if(!t)throw new TypeError(`"options" is required for lift method of Mutator, but received "${t}".`);if(!y(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const{type:r}=t;if(!n(r))throw new TypeError(`"type" is expected to be type of "String", but received "${typeof r}".`);if("both"===r)return this.liftBoth(e);if("left"===r)return this.liftLeft(e);if("right"===r)return this.liftRight(e);throw new TypeError(`"type" is expected be one of "both" | "left" | "right", but received "${r}".`)}static liftBoth(e){return lo(e),Q(2,((t,r,...o)=>e(mo(t)?t.value:t,mo(r)?r.value:r,...o)))}static liftLeft(e){return lo(e),Q(2,((t,r,...o)=>e(mo(t)?t.value:t,r,...o)))}static liftRight(e){return lo(e),Q(2,((t,r,...o)=>e(t,mo(r)?r.value:r,...o)))}fill(e){if(!mo(e))throw new TypeError(`The 1st parameter of Mutator's fill method is expected to be type of "Datar" | "Vacuo", but received "${typeof mutator}".`);return this.datar=e,this}fillEmpty(){return this.datar=yo,this}fillAuto(e=yo){return this.fill(e)}run(e=yo,...t){return this.operation(this.datar,mo(e)?e:ho.of(e),...t)}}const bo=e=>y(e)&&e.isAtom;class wo{get isAtom(){return!0}pipe(...e){return re(...e)(this)}compose(...e){return te(...e)(this)}}const To=e=>y(e)&&e.isMutation;class vo extends wo{constructor(e,t={}){if(super(),!y(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);if(this._options=t,oo(e))this._mutator=e;else{if(!f(e))throw new TypeError(`"operation" is expected to be type of "Mutator" | "Function", but received "${typeof e}".`);this._mutator=go.of(e)}this._consumers=new Set}get type(){return"MutationAtom"}get isMutation(){return!0}get isEmpty(){return this._mutator.isEmpty}static of(e,t={}){return new vo(e,t)}static empty(e={}){return new vo(go.empty(),e)}static ofLift(e,t={}){const{liftType:r}=t;return new vo(go.lift(e,{type:r}),{...t,isLifted:!0,origin_operation:e})}static ofLiftBoth(e,t={}){return new vo(go.liftBoth(e),{...t,isLifted:!0,origin_operation:e})}static ofLiftLeft(e,t={}){return new vo(go.liftLeft(e),{...t,isLifted:!0,origin_operation:e})}static ofLiftRight(e,t={}){return new vo(go.liftRight(e),{...t,isLifted:!0,origin_operation:e})}get mutator(){return this._mutator}get operation(){return this._options&&this._options.isLifted?this._options.origin_operation:this._mutator.operation}subscribe(e){return this._consumers.add(e),{unsubscribe:()=>this._consumers.delete(e)}}trigger(e){if(!c(e)&&!oo(e))throw new TypeError("Mutation must be triggered with a Mutator.");const t=e||this.mutator;S(t)||this._consumers.forEach((e=>{e(t,this)}))}triggerOperation(e){return this.trigger(go.of(e))}observe(e){if(!Eo(e))throw new TypeError("Mutation can only observe a Data!");return e.subscribe(((e,t)=>{this.mutate(e,t)}))}beObservedBy(e){return e.observe(this)}mutate(e,t){let r,o=null;if(o=ro(e)?e:Eo(e)?e.datar:ho.of(e),no(o.value))return this;if(t){if(!Eo(t))throw new TypeError(`"data" is expected to be type of "Data", but received "${typeof t}".`);r=t}else r=Eo(t)?e:r;const i=go.of(o.run(this._mutator,r)).fill(o);return this._mutator=i,this.trigger(),this}registerTrigger(e,t={}){if(!e)throw new TypeError(`"trigger" is required, but received "${e}".`);if(!f(e))throw new TypeError(`"trigger" is expected to be type of "Function", but received "${typeof e}".`);if(!y(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const{forceWrap:r=!1}=t;return e(((...e)=>{oo(e[0])&&!r||(e[0]=go.of(e[0])),this.trigger(...e)}))}}const Eo=e=>y(e)&&e.isData;class xo extends wo{constructor(e,t={}){if(super(),!y(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);this._options=t,ro(e)?this._datar=e:this._datar=ho.of(e),this._consumers=new Set}get type(){return"DataAtom"}get isData(){return!0}get isEmpty(){return this._datar.isEmpty}static of(e,t={}){return new xo(e,t)}static empty(e={}){return new xo(ho.empty(),e)}get datar(){return this._datar}get value(){return this._datar.value}subscribe(e){return this._consumers.add(e),{unsubscribe:()=>this._consumers.delete(e)}}trigger(e){if(!c(e)&&!ro(e))throw new TypeError("Data must be triggered with a Datar.");const t=e||this.datar;S(t)||this._consumers.forEach((e=>{e(t,this)}))}triggerValue(e){return this.trigger(ho.of(e))}observe(e){if(!To(e))throw new TypeError("Data can only observe a Mutation!");return e.subscribe(((e,t)=>{this.mutate(e,t)}))}beObservedBy(e){return e.observe(this)}mutate(e,t){let r,o;if(oo(e))r=e;else if(To(e))r=e.mutator;else{if(!f(e))throw new TypeError(`"mutator" is expected to be type of "Mutator" | "Mutation" | "Function", but received "${typeof e}".`);r=go.of(e)}if(t){if(!To(t))throw new TypeError(`"mutation" is expected to be type of "Mutation", but received "${typeof t}".`);o=t}else o=To(e)?e:o;const i=ho.of(r.run(this._datar,o)).fill(r);return no(i.value)||(this._datar=i,this.trigger()),this}registerTrigger(e,t={}){if(!e)throw new TypeError(`"trigger" is required, but received "${e}".`);if(!f(e))throw new TypeError(`"trigger" is expected to be type of "Function", but received "${typeof e}".`);if(!y(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const{forceWrap:r=!1}=t;return e(((...e)=>(ro(e[0])&&!r||(e[0]=ho.of(e[0])),this.trigger(...e))))}}const Lo=e=>y(e)&&e.isMediator;class jo{constructor(e){if(new.target===jo)throw new Error("BaseMediator can not be instantiated!");this._atom=e}get isMediator(){return!0}get atom(){return this._atom}get isAtom(){return this._atom.isAtom}get isData(){return this._atom.isData}get isMutation(){return this._atom.isMutation}get isEmpty(){return this._atom.isEmpty}get datar(){if(this.isData)return this._atom.datar;throw new TypeError('There is no "datar" property on Mutation instance.')}get value(){if(this.isData)return this._atom.value;throw new TypeError('There is no "value" property on Mutation instance.')}get mutator(){if(this.isMutation)return this._atom.mutator;throw new TypeError('There is no "mutator" property on Data instance.')}get operation(){if(this.isMutation)return this._atom.operation;throw new TypeError('There is no "operation" property on Data instance.')}subscribe(...e){return this._atom.subscribe(...e)}trigger(...e){return this._atom.trigger(...e)}triggerValue(...e){if(this.isData)return this._atom.triggerValue(...e);throw new TypeError('There is no "triggerValue" method on Mutation instance.')}triggerOperation(...e){if(this.isMutation)return this._atom.triggerOperation(...e);throw new TypeError('There is no "triggerOperation" method on Data instance.')}observe(...e){return this._atom.observe(...e)}beObservedBy(...e){return this._atom.beObservedBy(...e)}mutate(...e){return this._atom.mutate(...e)}registerTrigger(...e){return this._atom.registerTrigger(...e)}pipe(...e){return re(...e)(this)}compose(...e){return te(...e)(this)}release(){this._atom=null}}const Oo=e=>y(e)&&e.isTriggerMediator;class Ao extends jo{constructor(e){super(e),this._map=new WeakMap}get type(){return"TriggerMediator"}get isTriggerMediator(){return!0}static of(e){if(!bo(e))throw new TypeError("TriggerMediator can apply to an Atom only.");return new Ao(e)}get map(){return this._map}_add(e,t){return this._map.set(e,t)}_remove(e){return this._map.delete(e)}register(e,t){const r=this._atom.registerTrigger(e,t);return r&&this._add(e,r),r}get(e){return this._map.get(e)}remove(e){const t=this._map.get(e);return t&&t.cancel(),this._remove(e)}removeAll(){let e=!1;return this._map.forEach(((t,r)=>{t.cancel(),e=this._remove(r)&&e})),e}release(){this.removeAll(),super.release()}}const Mo=e=>y(e)&&e.isReplayMediator;class _o extends jo{constructor(e,t=1){super(e),this._history=[],this._consumers=[],this.setReplayTime(t),this._subscribeController=e.subscribe((e=>{this._history.push(e),this._setHistory()}))}get type(){return"ReplayMediator"}get isReplayMediator(){return!0}static of(e,t){if(!bo(e))throw new TypeError("ReplayMediator can apply to an Atom only.");if(Mo(e))return e;let r={};if(a(t))r.replayTime=t;else{if(!y(t))throw new TypeError(`"options" argument of ReplayMediator is expected to be type of "Number" | "Object", but received ${typeof t}.`);r={...r,...t}}const{replayTime:o,autoTrigger:i=!0}=r,n=new _o(e,o);return i&&e.trigger(),n}setReplayTime(e){if(!a(e))throw new TypeError("repalyTime is expected to be a Number.");this._replayTime=Math.floor(Math.abs(e)),this._setHistory()}_setHistory(){const e=this._history.length-this._replayTime;this._history=this._history.slice(e>=0?e:0)}replayTo(e){this._history.forEach((t=>{e(t)}))}replay(){this._consumers.forEach((e=>{this.replayTo(e)}))}subscribe(e){this._consumers.push(e);const t=this._atom.subscribe(e);return this.replayTo(e),t}beObservedBy(...e){return e[0].observe(this)}release(){this._subscribeController.unsubscribe(),super.release()}}const Fo=G(2,((e,t)=>_o.of(t,{replayTime:e,autoTrigger:!1}))),Do=G(2,((e,t)=>_o.of(t,{replayTime:e,autoTrigger:!0}))),$o=e=>y(e)&&e.isFlatMediator;class So extends jo{constructor(e,t){const r=xo.empty();super(r),this._atom=r,this._origin_atom=e,this._connection=null,this._subscribeController=null,this.options=t;const{autoConnect:o}=this.options;o&&this.connect()}get type(){return"FlatMediator"}get isFlatMediator(){return!0}static of(e,t){if(!bo(e))throw new TypeError("FlatMediator can apply to an Atom only.");const{autoConnect:r=!0}=t;return new So(e,{autoConnect:r})}connect(){if(this._origin_atom.isData){const e=vo.ofLiftLeft((e=>e));this._subscribeController=this._origin_atom.subscribe((({value:t})=>{const r=this._atom.observe(e),o=e.observe(t);t.trigger(),this._connection={unsubscribe:()=>{r.unsubscribe(),o.unsubscribe()}}}))}else if(this.isMutation){const e=xo.empty(),t=vo.ofLiftLeft((e=>e));this._subscribeController=e.subscribe((({value:e})=>{const r=this._atom.observe(t),o=t.observe(e);e.trigger(),this._connection={unsubscribe:()=>{r.unsubscribe(),o.unsubscribe()}}})),e.observe(this._origin_atom)}}disconnect(){this._connection&&(this._connection.unsubscribe(),this._connection=null)}release(){this._subscribeController.unsubscribe(),super.release()}}const ko=Q(1,((e,t={})=>So.of(e,t))),Co=()=>xo.empty(),Io=()=>vo.empty(),No=(e,t)=>xo.of(e,t),Uo=(e,t)=>t&&y(t)?vo.ofLift(e,t):vo.of(e),Po=(e,t)=>vo.ofLiftLeft(e,t),Wo=(e,t)=>vo.ofLiftRight(e,t),Ro=(e,t)=>vo.ofLiftBoth(e,t),Bo={liftType:"both"},Vo=Q(1,((e,t={})=>{if(!To(e))throw new TypeError(`"mutation" is expected to be type of "Mutation", but received "${typeof e}".`);if(!y(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const r=xo.empty(t);return r.observe(e),Mo(e)?Do(1,r):r})),qo=Q(2,((e,t,r={...Bo})=>{if(!f(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!To(t))throw new TypeError(`"mutation" is expected to be type of "Mutation", but received "${typeof t}".`);if(!y(r))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof r}".`);const o=xo.empty(),i=vo.ofLift(e,r),n=xo.empty();return n.observe(i),i.observe(o),o.observe(t),Mo(t)?Do(1,n):n})),zo=Q(2,((e,t,r={...Bo})=>{if(!f(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!Eo(t))throw new TypeError(`"data" is expected to be type of "Data", but received "${typeof t}".`);if(!y(r))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof r}".`);const o=vo.ofLift(e,r),i=xo.empty();return i.observe(o),o.observe(t),Mo(t)?Do(1,i):i})),Ho=Q(2,((e,t,r={...Bo})=>{if(!f(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!bo(t))throw new TypeError(`"atom" is expected to be type of "Mutation" | "Data", but received "${typeof t}".`);if(To(t))return qo(e,t,r);if(Eo(t))return zo(e,t,r);throw new TypeError('Unrecognized type of "Atom" received in atomToData, expected "Mutation" | "Data".')})),Jo=Q(1,((e,t={})=>{if(!Eo(e))throw new TypeError(`"data" is expected to be type of "Data", but received "${typeof e}".`);if(!y(t))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof t}".`);const r=vo.ofLiftBoth((e=>e),t);return r.observe(e),Mo(e)?Do(1,r):r})),Go=Q(2,((e,t,r={...Bo})=>{if(!f(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!Eo(t))throw new TypeError(`"data" is expected to be type of "Data", but received "${typeof t}".`);if(!y(r))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof r}".`);const o=vo.ofLift(e,r);return o.observe(t),Mo(t)?Do(1,o):o})),Zo=Q(2,((e,t,r={...Bo})=>{if(!f(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!To(t))throw new TypeError(`"mutation" is expected to be type of "Mutation", but received "${typeof t}".`);if(!y(r))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof r}".`);const o=xo.empty(),i=vo.ofLift(e,r);return i.observe(o),o.observe(t),Mo(t)?Do(1,i):i})),Qo=Q(2,((e,t,r={...Bo})=>{if(!f(e))throw new TypeError(`"transform" is expected to be type of "Function", but received "${typeof e}".`);if(!bo(t))throw new TypeError(`"atom" is expected to be type of "Mutation" | "Data", but received "${typeof t}".`);if(To(t))return Zo(e,t,r);if(Eo(t))return Go(e,t,r);throw new TypeError('Unrecognized type of "Atom" received in atomToMutation, expected "Mutation" | "Data".')})),Ko=e=>xo.of(e),Xo=e=>Eo(e)?e:To(e)?Vo(e):xo.of(e),Yo=Q(1,((e,t={})=>{if(!d(e))throw new TypeError(`"arr" argument in createDataInArray is expected to be type of "Array", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o=r?Ko:Xo;return e.map(o)})),ei=Q(1,((e,t={})=>{if(!y(e))throw new TypeError(`"obj" argument in createDataInObject is expected to be type of "Objcet", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o={},i=r?Ko:Xo;return Object.entries(e).map((([e,t])=>{o[e]=i(t)})),o})),ti=e=>vo.of((()=>e)),ri=e=>Eo(e)?Jo(e):To(e)?e:oo(e)?vo.of(e):f(e)?vo.ofLiftBoth(e):vo.of((()=>e)),oi=Q(1,((e,t={})=>{if(!d(e))throw new TypeError(`"arr" argument in createMutationInArray is expected to be type of "Array", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o=r?ti:ri;return e.map(o)})),ii=Q(1,((e,t={})=>{if(!y(e))throw new TypeError(`"obj" argument in createMutationInObject is expected to be type of "Objcet", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o={},i=r?ti:ri;return Object.entries(e).map((([e,t])=>{o[e]=i(t)})),o})),ni=e=>xo.of(e),ai=e=>bo(e)?e:oo(e)?vo.of(e):f(e)?vo.ofLiftBoth(e):xo.of(e),si=Q(1,((e,t={})=>{if(!d(e))throw new TypeError(`"arr" argument in createAtomInArray is expected to be type of "Array", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o=r?ni:ai;return e.map(o)})),ci=Q(1,((e,t={})=>{if(!y(e))throw new TypeError(`"obj" argument in createMutationInObject is expected to be type of "Objcet", but received ${typeof e}.`);const{forceWrap:r=!1}=t,o={},i=r?ni:ai;return Object.entries(e).map((([e,t])=>{o[e]=i(t)})),o})),pi=Q(2,((e,t,r)=>[e,t.of(e,r)])),fi=Q(1,((e,t={})=>pi(e,_o,t))),ui=Q(1,((e,t={})=>pi(e,Ao,t))),yi=(e={})=>fi(xo.empty(),e),di=(e={})=>fi(vo.empty(),e),hi=()=>ui(xo.empty()),li=()=>ui(vo.empty()),mi=(e={})=>{const[t,r]=yi(e);return[t,r,e]},gi=(e={})=>{const[t,r]=di(e);return[t,r,e]},bi=e=>{const[t,r]=hi(),o=r.register(e);return[t,r,e,o]},wi=e=>{const[t,r]=li(),o=r.register(e);return[t,r,e,o]},Ti=({iterable:e,handler:t=k,autoStart:r=!1,repeatable:o=!0}={})=>{if(!f(t))throw new TypeError('"handler" is expected to be a Function.');if(!D(e))throw new TypeError('"iterable" is expected to be iterable.');const i={times:0,done:!1,values:[]},n=new WeakSet,a=()=>{try{i.values=[...e],i.values.forEach((e=>{n.forEach((r=>{r(t(e))}))})),i.done=!0,i.times+=1}catch(e){}return i};return e=>(n.add(e),r&&a(),{start:()=>((o||0===i.times)&&a(),i),cancel:()=>{}})},vi=(...e)=>{let t={};if(1===e.length)t=y(e[0])&&Lr("iterable",e[0])?e[0]:{iterable:e[0]};else if(e.length>1){const r=["autoStart","repeatable"];e.forEach((e=>{D(e)?t.iterable=t.iterable||e:f(e)?t.handler=t.handler||e:i(e)&&(t[r.shift()]=e)}))}return t},Ei=te(Ti,vi),xi=te(bi,Ei),Li=te(wi,Ei),ji=({target:e,type:t,handler:r=k}={})=>{if(!f(r))throw new TypeError('"handler" is expected to be a Function.');if(!F(e))throw new TypeError('"target" is expected to be an instance of EventTarget.');return o=>{const i=e=>{o(r(e))};return e.addEventListener(t,i),{cancel:()=>{e.removeEventListener(t,i)}}}},Oi=(...e)=>{let t={};return 1===e.length?t=y(e[0])&&Lr("target",e[0])?e[0]:{target:e[0]}:e.length>1&&e.forEach((e=>{o(e)?t.target=t.target||e:n(e)?t.type=t.type||e:f(e)&&(t.handler=t.handler||e)})),t},Ai=te(ji,Oi),Mi=te(bi,Ai),_i=te(wi,Ai),Fi=({handler:e=k,start:t=0,step:r=1e3,interval:o=1e3,autoStart:i=!0}={})=>{if(!f(e))throw new TypeError('"handler" is expected to be a Function.');let n=t,a=0,s=!1;const c=new WeakSet,p=()=>{s=!0;try{a=setInterval((()=>{n+=r,c.forEach((t=>{t(e(n))}))}),o)}catch(e){s=!1}return a};return e=>(c.add(e),!s&&i&&p(),{start:()=>s?a:p(),cancel:()=>{clearInterval(a)}})},Di=(...e)=>{let t={};if(1===e.length)y(e[0])&&(t=e[0]);else if(e.length>1){const r=["start","step","interval","autoStart","handler"];e.forEach((e=>{f(e)?t.handler=t.handler||e:t[r.shift()]=e}))}return t},$i=te(Fi,Di),Si=te(bi,$i),ki=te(wi,$i),Ci=({timeout:e,handler:t=k,autoStart:r=!0}={})=>{if(!f(t))throw new TypeError('"handler" is expected to be a Function.');if(!a(e))throw new TypeError('"timeout" is required and expected to be a Number.');let o=!1,i=0;const n=new WeakSet,s=()=>{o=!0;try{i=setTimeout((()=>{n.forEach((e=>{e(t())}))}),e)}catch(e){o=!1}return i};return e=>(n.add(e),!o&&r&&s(),{start:()=>o?i:s(),cancel:()=>{clearTimeout(i)}})},Ii=(...e)=>{let t={};return 1===e.length?y(e[0])&&(t=e[0]):e.length>1&&e.forEach((e=>{a(e)?t.timeout=Lr("timeout",t)?t.timeout:e:f(e)?t.handler=Lr("handler",t)?t.handler:e:i(e)&&(t.autoStart=Lr("autoStart",t)?t.autoStart:e)})),t},Ni=te(Ci,Ii),Ui=te(bi,Ni),Pi=te(wi,Ni),Wi=({observable:e,handler:t=k,autoStart:r=!0})=>{if(!f(t))throw new TypeError('"handler" is expected to be a Function.');if(!$(e))throw new TypeError('"observable" is expected to be an observable object which implements the subscribe method.');let o,i=!1;const n=new WeakSet,a=()=>{try{i=!0,o=e.subscribe((e=>{n.forEach((r=>{r(t(e))}))}))}catch(e){i=!1}return o};return e=>(n.add(e),!i&&r&&a(),{start:()=>i?o:a(),cancel:()=>o.unsubscribe()})},Ri=(...e)=>{let t={};return 1===e.length?y(e[0])&&(t=e[0]):e.length>1&&e.forEach((e=>{$(e)?t.observable=Lr("observable",t)?t.observable:e:f(e)?t.handler=Lr("handler",t)?t.handler:e:i(e)&&(t.autoStart=Lr("autoStart",t)?t.autoStart:e)})),t},Bi=te(Wi,Ri),Vi=te(bi,Bi),qi=te(wi,Bi),zi=({agent:e,handler:t=k,autoStart:r=!0})=>{if(!f(e))throw new TypeError('"agent" is expected to be a Function.');if(!f(t))throw new TypeError('"handler" is expected to be a Function.');let o=r;return r=>{let i=(...e)=>{o&&r(t(...e))};return e(i),{start:()=>{o=!0},pause:()=>{o=!1},cancel:()=>{o=!1,i=null}}}},Hi=(...e)=>{let t={};return 1===e.length?y(e[0])?t=e[0]:f(e[0])&&(t.agent=e[0]):e.length>1&&e.forEach((e=>{f(e)?t.agent?t.handler||(t.handler=e):t.agent=e:i(e)&&(t.autoStart=Lr("autoStart",t)?t.autoStart:e)})),t},Ji=te(zi,Hi),Gi=te(bi,Ji),Zi=te(wi,Ji),Qi=ne(2,"observe"),Ki=ne(2,"beObservedBy"),Xi=e=>Lo(e)?Xi(e.atom):e.type,Yi=G(2,((e,t)=>!(!bo(e)||!bo(t))&&Xi(e)===Xi(t))),en=G(2,((e,t)=>Lo(e)&&Lo(t)&&e.type===t.type)),tn=(...e)=>(e.reverse().forEach(((e,t,r)=>{t>=1&&e.beObservedBy(r[t-1])})),e[e.length-1]),rn=(...e)=>(e.forEach(((e,t,r)=>{t>=1&&e.beObservedBy(r[t-1])})),e[0]),on=(e,t)=>{if(!bo(e))throw new TypeError('"upstreamAtom" argument of binaryTweenPipeAtom are expected to be type of "Mutation" or "Data".');if(!bo(t))throw new TypeError('"downstreamAtom" argument of binaryTweenPipeAtom are expected to be type of "Mutation" or "Data".');if(Yi(e,t)){let r;if(Eo(e))r=vo.ofLiftLeft((e=>e));else{if(!To(e))throw new TypeError("Unexpected type of Atom detected!");r=xo.empty()}return tn(e,r,t)}return tn(e,t)},nn=we(on),an=(...e)=>{},sn=(...e)=>{},cn=()=>{},pn=()=>{},fn=(...e)=>{},un=(...e)=>{},yn=()=>{},dn=()=>{},hn=(...e)=>{},ln=(...e)=>{},mn={liftType:"both"},gn=Q(2,((e={},t={...mn})=>{if(!y(e)&&!f(e))throw new TypeError(`"createOptions" is expected to be type of "Object" | "Function", but received "${typeof e}".`);f(e)&&(e={prepareMidpiece:e});const{prepareTacheLevelContexts:r=(()=>({})),prepareOptions:o=(e=>e),prepareInput:i=((e,t,r)=>r),prepareMidpiece:n=(()=>vo.ofLiftBoth((e=>e))),prepareOutput:a=(()=>xo.empty()),connect:s=((e,[t,r,o])=>{tn(r,o),on(t,r)})}=e,c=r();if(!y(c))throw new TypeError(`"tacheLevelContexts" is expected to be type of "Object", but received "${typeof c}".`);if(!y(t))throw new TypeError(`"tacheOptions" is expected to be type of "Object", but received "${typeof t}".`);if(t=o(t),!y(t))throw new TypeError(`The returned value of "prepareOptions" is expected to be type of "Object", but received "${typeof t}".`);return(...e)=>{const r=i(t,c,e.length>1?e:e[0]),o=n(t,c,r),p=a(t,c,o);return s(t,c,[r,o,p]),p}})),bn=Q(3,((e,t,...r)=>{const o=e(t);return r.length>1?o(...r):o(r[0])})),wn=(e,t={...mn})=>{if(y(e)&&e.operation&&(t=e.options?{...mn,...e.options}:{...mn},e=e.operation),!f(e))throw new TypeError(`"operation" is expected to be type of "Function", but received ${typeof e}.`);const{liftType:r="both"}=t;return t=>{if(!bo(t))throw new TypeError('"target" is expected to be type of "Atom".');const o=vo.ofLift(e,{liftType:r}),i=xo.empty();return tn(o,i),on(t,o),i}},Tn=(...e)=>1===e.length&&y(e[0])?En(e[0]):1===e.length&&d(e[0])?vn(...e[0]):e.length>1?vn(...e):void 0,vn=(...e)=>(1===e.length&&d(e[0])&&(e=e[0]),e=e.map((e=>{let t,r;if(y(e)&&e.operation)r=e.options?{...mn,...e.options}:{...mn},t=e.operation;else{if(!f(e))throw new TypeError(`"config" is expected to be type of "Object" | "Function", but received ${typeof e}.`);r={...mn},t=e}if(!f(t))throw new TypeError(`"operation" is expected to be type of "Function", but received ${typeof e}.`);return{operation:t,options:r}})),t=>{if(!bo(t))throw new TypeError('"target" is expected to be type of "Atom".');const r=e.map((({operation:e,options:t})=>{const{liftType:r="both"}=t;return vo.ofLift(e,{liftType:r})})),o=Array.from({length:e.length}).map((()=>xo.empty()));return o.forEach(((e,o)=>{tn(r[o],e),on(t,r[o])})),o}),En=e=>{if(!y(e))throw new TypeError(`"configObj" is expected to be type of "Object", but received ${typeof e}.`);return e=Object.entries(e).reduce(((e,[t,r])=>{let o,i;if(y(r)&&r.operation)i=r.options?{...mn,...r.options}:{...mn},o=r.operation;else{if(!f(r))throw new TypeError(`"config" is expected to be type of "Object" | "Function", but received ${typeof r}.`);i={...mn},o=r}if(!f(o))throw new TypeError(`"operation" is expected to be type of "Function", but received ${typeof r}.`);return e[t]=e[t]||{operation:o,options:i},e}),{}),t=>{if(!bo(t))throw new TypeError('"target" is expected to be type of "Atom".');const r=Object.entries(e).reduce(((e,[t,{operation:r,options:o}])=>{const{liftType:i="both"}=o;return e[t]=e[t]||vo.ofLift(r,{liftType:i}),e}),{}),o=Object.entries(e).reduce(((e,[t])=>(e[t]=e[t]||xo.empty(),e)),{});return Object.entries(o).forEach((([e,o])=>{tn(r[e],o),on(t,r[e])})),o}},xn=(e={})=>{if(!y(e))throw new TypeError(`"config" is expected to be type of "Object", but received "${typeof e}".`);const{sourcesType:t}=e;return"array"===t.toLowerCase()?Ln(e):"object"===t.toLowerCase()?jn(e):(...t)=>1===t.length&&y(t[0])?jn(e)(t[0]):1===t.length&&d(t[0])?Ln(e)(...t[0]):t.length>1?vn(e)(...t):void 0},Ln=(e={})=>{if(!y(e))throw new TypeError(`"config" is expected to be type of "Object", but received ${typeof e}.`);const{numberOfSources:t,acceptNonAtom:r=!0,opCustomizeType:o="partly",opLiftType:i="both",operation:a,autoUpdateContexts:s=!0}=e;if(!n(o))throw new TypeError(`"opCustomizeType" is expected to be type of "String", but received "${typeof o}".`);if("partly"!==o.toLowerCase()&&"fully"!==o.toLowerCase())throw new TypeError(`"opCustomizeType" is expected to be "fully" | "partly", but received "${o}".`);if(void 0===a)throw new TypeError('"operation" is required when use makeArrayMSTache to make tache.');if(!f(a))throw new TypeError(`"operation" is expected to be type of "Function", but received ${typeof a}.`);const c=(...e)=>{r?e=e.map((e=>bo(e)?e:Do(1,xo.of(e)))):e.forEach((e=>{if(!bo(e))throw new TypeError(`"source" is expected to be type of "Atom", but received ${typeof e}.`)}));const t=e.length,n=Array.from({length:t}).map(((e,t)=>vo.ofLiftLeft((e=>({id:t,value:e}))))),c=Array.from({length:t}).map((()=>xo.empty())),p=vo.ofLift((()=>{const e={numberOfSources:t,TERMINATOR:fo};if("fully"===o.toLowerCase()){const t={...e},r=a(t);if(!f(r))throw new TypeError('"operation" is expected to return a "Function" when "opCustomizeType" is specified to "fully".');return r}if("partly"===o.toLowerCase()){const r={...e,states:Array.from({length:t}),values:Array.from({length:t})};return(e,t,o,...i)=>{if(s){const{id:t,value:o}=e;r.states[t]=!0,r.values[t]=o}return a(e,t,o,r,...i)}}})(),{liftType:i}),u=xo.empty();return tn(p,u),c.forEach((e=>{tn(e,p)})),n.forEach(((e,t)=>{tn(e,c[t])})),e.forEach(((e,t)=>{on(e,n[t])})),u};return t?Q(t,c):(...e)=>(1===e.length&&d(e[0])&&(e=e[0]),c(...e))},jn=(e={})=>{if(!y(e))throw new TypeError(`"config" is expected to be type of "Object", but received "${typeof e}".`);const{acceptNonAtom:t=!0,opCustomizeType:r="partly",opLiftType:o="both",operation:i,autoUpdateContexts:a=!0}=e;if(!n(r))throw new TypeError(`"opCustomizeType" is expected to be type of "String", but received "${typeof r}".`);if("partly"!==r.toLowerCase()&&"fully"!==r.toLowerCase())throw new TypeError(`"opCustomizeType" is expected to be "fully" | "partly", but received "${r}".`);if(void 0===i)throw new TypeError('"operation" is required when use makeObjectMSTache to make tache.');if(!f(i))throw new TypeError(`"operation" is expected to be type of "Function", but received "${typeof i}".`);return e=>{if(!y(e))throw new TypeError(`"sources" is expected to be type of "Object", but received "${typeof e}".`);t?e=Object.entries(e).reduce(((e,[t,r])=>(e[t]=e[t]||(bo(r)?r:Do(1,xo.of(r))),e)),{}):Object.values(e).forEach((e=>{if(!bo(e))throw new TypeError(`"source" is expected to be type of "Atom", but received "${typeof e}".`)}));const n=Object.entries(e).reduce(((e,[t])=>(e[t]=vo.ofLiftLeft((e=>({key:t,value:e}))),e)),{}),s=Object.entries(e).reduce(((e,[t])=>(e[t]=xo.empty(),e)),{}),c=vo.ofLift((()=>{const t={keysOfSources:Object.keys(e),TERMINATOR:fo};if("fully"===r.toLowerCase()){const e={...t},r=i(e);if(!f(r))throw new TypeError('"operation" is expected to return a "Function" when "opCustomizeType" is specified to "fully".');return r}if("partly"===r.toLowerCase()){const r={...t,states:Object.keys(e).reduce(((e,t)=>(e[t]=!1,e)),{}),values:Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{})};return(e,t,o,...n)=>{if(a){const{key:t,value:o}=e;r.states[t]=!0,r.values[t]=o}return i(e,t,o,r,...n)}}})(),{liftType:o}),p=xo.empty();return tn(c,p),Object.values(s).forEach((e=>{tn(e,c)})),Object.entries(n).forEach((([e,t])=>{tn(t,s[e])})),Object.entries(e).forEach((([e,t])=>{on(t,n[e])})),p}},On=()=>{throw new Error("makeMMTache to be developed.")},An=e=>{if(!bo(e))throw new TypeError('"target" argument of nilToVoidT is expected to be type of "Atom" only.');const t=vo.ofLiftLeft((e=>ht(e)?co:e)),r=xo.empty();return tn(t,r),on(e,t),r},Mn=()=>{},_n=G(2,((e,t)=>bo(e)?Fn(e,t):Dn(e,t))),Fn=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"dft" argument of dynamicDefautToT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicDefautToT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"dft",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={dft:!1,target:!1},t={dft:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("dft"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in defaultM, expected to be "dft" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.dft&&e.target?"dft"===o?fo:"target"===o?io(t.target)?t.dft:t.target:void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Dn=G(2,((e,t)=>Fn(Do(1,xo.of(e)),t))),$n=G(2,((e,t)=>{if(n(e)||d(e))return kn(e,t);if(bo(e))return Sn(e,t);throw new TypeError('"selector" argument of pluckT is expected to be type of "String" | "Array" | "Atom".')})),Sn=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"selector" argument of dynamicPluckT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"selector" argument of dynamicPluckT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"selector",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={selector:!1,target:!1},t={selector:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("selector"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in pluckM, expected to be "selector" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.selector&&e.target?"selector"===o?fo:"target"===o?_r(t.selector,t.target):void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),kn=G(2,((e,t)=>{if(!n(e)&&!d(e))throw new TypeError('"selector" argument of staticPluckT is expected to be type of "String" | "Array".');return Sn(Do(1,xo.of(e)),t)})),Cn=G(2,((e,t)=>{if(f(e))return Nn(e,t);if(bo(e))return In(e,t);throw new TypeError('"fn" argument of mapT is expected to be type of "Function" or "Atom".')})),In=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"fn" argument of dynamicMapT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicMapT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"map",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={map:!1,target:!1,index:-1},t={map:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("map"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in mapM, expected to be "map" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.map&&e.target?"map"===o?fo:"target"===o?(e.index=e.index+1,t.map(t.target,e.index)):void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Nn=G(2,((e,t)=>{if(!f(e))throw new TypeError('"fn" argument of staticMapT is expected to be type of "Function".');return In(Do(1,xo.of(e)),t)})),Un=G(2,((e,t)=>{if(f(e))return Wn(e,t);if(bo(e))return Pn(e,t);throw new TypeError('"pred" argument of filterT is expected to be type of "Function" or "Atom".')})),Pn=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"pred" argument of dynamicFilterT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicFilterT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"pred",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={pred:!1,target:!1,index:-1},t={pred:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("pred"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in filterM, expected to be "pred" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.pred&&e.target?"pred"===o?fo:"target"===o?(e.index=e.index+1,t.pred(t.target,e.index)?t.target:fo):void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Wn=G(2,((e,t)=>{if(!f(e))throw new TypeError('"pred" argument of staticFilterT is expected to be type of "Function".');return Pn(Do(1,xo.of(e)),t)})),Rn=G(2,((e,t)=>bo(e)?Bn(e,t):Vn(e,t))),Bn=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"start" argument of dynamicStartWithT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicStartWithT is expected to be type of "Atom".');e=Do(1,e);const r=vo.ofLiftLeft((e=>({type:"start",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={start:!1,target:!1,startExpired:!1},t={start:void 0,target:void 0,targetQueue:[]};return(r,o,i)=>{const{type:n,value:a}=r;if("start"!==n&&"target"!==n)throw new TypeError(`Unexpected type of wrapped Data received in startM, expected to be "start" | "target", but received "${n}".`);return e[n]=!0,t[n]=a,"target"===n?e.startExpired?t.target:(t.targetQueue.push(a),fo):"start"===n&&e.startExpired?fo:"start"!==n||e.startExpired?void 0:(e.startExpired=!0,t.targetQueue.unshift(a),t.targetQueue.forEach((e=>{i.triggerOperation((()=>e))})),t.targetQueue.length=0,fo)}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Vn=G(2,((e,t)=>Bn(Do(1,xo.of(e)),t))),qn=G(2,((e,t)=>bo(e)?zn(e,t):Hn(e,t))),zn=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"start" argument of dynamicEmptyStartWithT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicEmptyStartWithT is expected to be type of "Atom".');e=Do(1,e),t=Do(1,t);const r=vo.ofLiftLeft((e=>({type:"start",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={start:!1,target:!1,startExpired:!1},t={start:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("start"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in startM, expected to be "start" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,"target"===o?t.target:"start"===o&&e.startExpired?fo:"start"!==o||e.startExpired?void 0:(e.startExpired=!0,e.target?fo:t.start)}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Hn=G(2,((e,t)=>zn(Do(1,xo.of(e)),t))),Jn=G(2,((e,t)=>{if(a(e))return Zn(e,t);if(bo(e))return Gn(e,t);throw new TypeError('"timer" argument of debounceTimeT is expected to be type of "Number" or "Atom".')})),Gn=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"timer" argument of dynamicDebounceTimeT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicDebounceTimeT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"timer",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={timer:!1,target:!1,clock:0},t={timer:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("timer"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in debounceM, expected to be "timer" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.timer&&e.target?"timer"===o?fo:"target"===o?(clearTimeout(e.clock),e.clock=setTimeout((()=>{a.triggerOperation((()=>t.target))}),t.timer),fo):void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Zn=G(2,((e,t)=>{if(!a(e))throw new TypeError('"ms" argument of staticDebounceTimeT is expected to be type of "Number".');return Gn(Do(1,xo.of(e)),t)})),Qn=G(2,((e,t)=>{if(a(e))return Xn(e,t);if(bo(e))return Kn(e,t);throw new TypeError('"timer" argument of throttleTimeT is expected to be type of "Number" or "Atom".')})),Kn=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"timer" argument of dynamicThrottleTimeT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicThrottleTimeT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"timer",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={timer:!1,target:!1,clock:0,canEmit:!0},t={timer:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("timer"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in throttleM, expected to be "timer" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.timer&&e.target?"timer"===o?fo:"target"===o?e.canEmit?(e.canEmit=!1,e.clock=setTimeout((()=>{clearTimeout(e.clock),e.canEmit=!0}),t.timer),t.target):fo:void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Xn=G(2,((e,t)=>{if(!a(e))throw new TypeError('"ms" argument of staticThrottleTimeT is expected to be type of "Number".');return Kn(Do(1,xo.of(e)),t)})),Yn=G(2,((e,t)=>{if(a(e))return ta(e,t);if(bo(e))return ea(e,t);throw new TypeError('"n" argument of withHistoryT is expected to be type of "Number" or "Atom"')})),ea=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"n" argument of withDynamicHistoryT is expected to be type of "Mutation" or "Data".');if(!bo(t))throw new TypeError('"target" argument of withDynamicHistoryT is expected to be type of "Mutation" or "Data".');const r=vo.ofLiftLeft((e=>({type:"n",value:parseInt(e)}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={n:!1,target:!1,history:[]},t={n:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("n"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in withHistoryM, expected to be "n" | "target", but received "${o}"`);e[o]=!0,t[o]=i;const{history:n}=e;return"n"===o?(n.length=i,fo):"target"===o?(n.pop(),n.unshift(i),[...n]):void 0}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),ta=G(2,((e,t)=>{if(!a(e))throw new TypeError('"n" argument of withStaticHistoryT is expected to be type of "Number".');return ea(Do(1,xo.of(e)),t)})),ra=Yn(2),oa=re(ra,Un((e=>e[0]&&e[1]))),ia=e=>G(2,((t,r)=>{if(!bo(t))throw new TypeError('"to" argument of switchT is expected to be type of "Atom".');if(!bo(r))throw new TypeError('"from" argument of switchT is expected to be type of "Atom".');const o=vo.ofLiftLeft((e=>({type:"to",value:e}))),i=xo.empty();tn(o,i);const n=vo.ofLiftLeft((e=>({type:"from",value:e}))),a=xo.empty();tn(n,a);const s=e();tn(i,s),tn(a,s);const c=xo.empty();return tn(s,c),on(t,o),on(r,n),c})),na=G(2,((e,t)=>bo(e)?aa(e,t):sa(e,t))),aa=ia((()=>vo.ofLiftLeft((()=>{const e={from:!1,to:!1},t={from:void 0,to:void 0};return r=>{const{type:o,value:i}=r;if("from"!==o&&"to"!==o)throw new TypeError(`Unexpected type of wrapped Data received in switchM, expected to be "from" | "to", but received "${o}"`);return e[o]=!0,t[o]=i,e.from&&e.to?"to"===o?fo:"from"===o?t.to:void 0:fo}})()))),sa=G(2,((e,t)=>aa(Do(1,xo.of(e)),t))),ca=ia((()=>{const e=vo.ofLiftLeft((()=>{const t={from:!1,to:!1,promise:!1},r={from:void 0,to:void 0};return o=>{const{type:i,value:n}=o;if("from"!==i&&"to"!==i)throw new TypeError(`Unexpected type of wrapped Data received in switchM, expected to be "from" | "to", but received "${i}"`);return t[i]=!0,r[i]=n,"to"===i?(t.promise&&(e.triggerOperation((()=>r.to)),t.promise=!1),fo):"from"===i?t.to?r.to:(t.promise=!0,fo):void 0}})());return e})),pa=G(2,((e,t)=>{if(f(e))return ua(e,t);if(bo(e))return fa(e,t);throw new TypeError('"transform" argument of distinctPreviousT is expected to be type of "Number" or "Atom".')})),fa=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"transform" argument of dynamicDistinctPreviousT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicDistinctPreviousT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"transform",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={transform:!1,target:!1,previous:void 0},t={transform:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("transform"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "transform" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.transform&&e.target?"transform"===o?fo:"target"===o?t.transform(e.previous)===t.transform(t.target)?fo:(e.previous=t.target,t.target):void 0:fo}})());tn(n,a),tn(o,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),ua=G(2,((e,t)=>{if(!f(e))throw new TypeError('"transform" argument of staticDistinctPreviousT is expected to be type of "Function".');return fa(Do(1,xo.of(e)),t)})),ya=pa((e=>e)),da=G(2,((e,t)=>{if(f(e))return la(e,t);if(bo(e))return ha(e,t);throw new TypeError('"transform" argument of distinctEverT is expected to be type of "Number" or "Atom".')})),ha=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"transform" argument of dynamicDistinctEverT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicDistinctEverT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"transform",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={transform:!1,target:!1,history:[]},t={transform:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("transform"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in distinctM, expected to be "transform" | "target", but received "${o}".`);if(e[o]=!0,t[o]=i,!e.transform||!e.target)return fo;if("transform"===o)return fo;if("target"===o){const r=t.transform(t.target),o=e.history;return o.includes(r)?fo:(o.push(r),t.target)}}})());tn(n,a),tn(o,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),la=G(2,((e,t)=>{if(!f(e))throw new TypeError('"transform" argument of staticDistinctEverT is expected to be type of "Function".');return ha(Do(1,xo.of(e)),t)})),ma=da((e=>e)),ga=G(2,((e,t)=>{if(a(e))return wa(e,t);if(bo(e))return ba(e,t);throw new TypeError('"n" argument of skipT is expected to be type of "Number" or "Atom".')})),ba=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"n" argument of dynamicSkipT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicSkipT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"n",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={n:!1,target:!1,index:-1,skiped:0},t={n:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("n"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "n" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.n&&e.target?"n"===o?fo:"target"===o?e.skiped<e.n?(e.skiped=e.skiped+1,fo):t.target:void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),wa=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"n" argument of staticSkipT is expected to be type of "Number".');return ba(Do(1,xo.of(e)),t)})),Ta=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"cond" argument of skipUntilT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of skipUntilT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"cond",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={cond:!1,target:!1},t={cond:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("cond"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "cond" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.cond&&e.target?"cond"===o?fo:"target"===o?t.target:void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),va=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"cond" argument of skipWhileT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of skipWhileT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"cond",value:Boolean(e)}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={cond:!1,target:!1},t={cond:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("cond"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "cond" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.cond&&e.target?"cond"===o?fo:"target"===o?t.cond?fo:t.target:void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Ea=G(2,((e,t)=>{if(a(e))return La(e,t);if(bo(e))return xa(e,t);throw new TypeError('"n" argument of takeT is expected to be type of "Number" or "Atom".')})),xa=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"n" argument of dynamicTakeT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicTakeT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"n",value:parseInt(e)}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={n:!1,target:!1,taked:0},t={n:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("n"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "n" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.n&&e.target?"n"===o?fo:"target"===o?e.taked<e.n?(e.taked=e.taked+1,t.target):fo:void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),La=G(2,((e,t)=>xa(Do(1,xo.of(e)),t))),ja=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"cond" argument of takeUntilT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of takeUntilT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"cond",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={cond:!1,target:!1},t={cond:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("cond"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "cond" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.cond?fo:"target"===o?t.target:void 0}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Oa=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"cond" argument of takeWhileT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of takeWhileT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"cond",value:Boolean(e)}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={cond:!1,target:!1},t={cond:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("cond"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received, expected to be "cond" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.cond&&e.target?"cond"===o?fo:"target"===o?t.cond?t.target:fo:void 0:fo}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Aa=G(4,((e,t,r,o)=>{if(f(e))return _a(e,t,r,o);if(bo(e))return Ma(e,t,r,o);throw new TypeError('"pred" argument of iifT is expected to be type of "Function" | "Atom".')})),Ma=G(4,((e,t,r,o)=>{if(!bo(e))throw new TypeError('"pred" argument of dynamicFilterT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"trueTarget" argument of dynamicFilterT is expected to be type of "Atom".');if(!bo(r))throw new TypeError('"falseTarget" argument of dynamicFilterT is expected to be type of "Atom".');if(!bo(o))throw new TypeError('"target" argument of dynamicFilterT is expected to be type of "Atom".');const i=vo.ofLiftLeft((e=>({type:"pred",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((e=>({type:"trueTarget",value:e}))),s=xo.empty();tn(a,s);const c=vo.ofLiftLeft((e=>({type:"falseTarget",value:e}))),p=xo.empty();tn(c,p);const f=vo.ofLiftLeft((e=>({type:"target",value:e}))),u=xo.empty();tn(f,u);const y=vo.ofLiftLeft((()=>{const e={pred:!1,trueTarget:!1,falseTarget:!1,target:!1,index:-1},t={pred:void 0,trueTarget:void 0,falseTarget:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("pred"!==o&&"trueTarget"!==o&&"falseTarget"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in filterM, expected to be "pred" | "trueTarget" | "falseTarget" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,e.pred&&e.target?"pred"===o||"trueTarget"===o||"falseTarget"===o?fo:"target"===o?(e.index=e.index+1,t.pred(t.target,e.index)?e.trueTarget?t.trueTarget:fo:e.falseTarget?t.falseTarget:fo):void 0:fo}})());tn(n,y),tn(s,y),tn(p,y);const d=xo.empty();return tn(y,d),on(e,i),on(t,a),on(r,c),d})),_a=G(4,((e,t,r,o)=>{if(!f(e))throw new TypeError('"pred" argument of staticIifT is expected to be type of "Function".');return Ma(Do(1,xo.of(e)),t,r,o)})),Fa=G(3,((e,t,r)=>{if(y(e)&&y(t))return ka(e,t,r);if(d(e)&&d(t))return Da(e,t,r);throw y(e)&&d(e)||d(e)&&y(t)?new TypeError('"preds" & "cases" argument of caseT are expected to be the same type.'):new TypeError('"preds & "cases" argument of caseT are expected to be type of "Object" | "Array".')})),Da=G(3,((e,t,r)=>{if(!d(e))throw new TypeError('"preds" argument of arrayCaseT is expected to be type of "Array".');if(!d(t))throw new TypeError('"cases" argument of arrayCaseT is expected to be type of "Array".');if(!bo(r))throw new TypeError('"target" argument of arrayCaseT is expected to be type of "Atom".');return e.some((e=>!bo(e)))||t.some((e=>!bo(e)))?Sa(e,t,r):$a(e,t,r)})),$a=G(3,((e,t,r)=>{if(!d(e))throw new TypeError('"preds" argument of dynamicArrayCaseT is expected to be type of "Array".');if(!d(t))throw new TypeError('"cases" argument of dynamicArrayCaseT is expected to be type of "Array".');if(e.length!==t.length)throw new TypeError('Lengths of "preds" & "cases" argument of arrayCaseT are expected to be equal.');if(e.forEach((e=>{if(!bo(e))throw new TypeError('"pred" in "preds" argument of dynamicArrayCaseT are expected to be type of "Atom".')})),t.forEach((e=>{if(!bo(e))throw new TypeError('"case" in "cases" argument of dynamicArrayCaseT are expected to be type of "Atom".')})),!bo(r))throw new TypeError('"target" argument of arrayCaseT is expected to be type of "Atom".');const o=e.map(((e,t)=>vo.ofLiftLeft((e=>({id:t,type:"pred",value:e}))))),i=t.map(((e,t)=>vo.ofLiftLeft((e=>({id:t,type:"case",value:e}))))),n=vo.ofLiftLeft((e=>({type:"target",value:e}))),a=e.map((()=>xo.empty())),s=t.map((()=>xo.empty())),c=xo.empty(),p=vo.ofLiftLeft((()=>{const r={pred:Array.from({length:e.length}),case:Array.from({length:t.length}),target:!1},o={pred:Array.from({length:e.length}),case:Array.from({length:t.length}),target:void 0};return e=>{const{id:t,type:i,value:n}=e;if("pred"!==i&&"case"!==i&&"target"!==i)throw new TypeError(`Unexpected type of wrapped Data received in caseM, expected to be "pred" | "case" | "target", but received "${i}"`);if("pred"!==i&&"case"!==i||(r[i][t]=!0,o[i][t]=n),"target"===i&&(r[i]=!0,o[i]=n),!r.target||r.pred.some((e=>!e)))return fo;if("pred"===i||"case"===i)return fo;if("target"===i){let e,t=!1;for(let i=0,n=o.pred.length;i<n&&!t;i++)return o.pred[i](o.target)&&(t=!0,e=r.case[i]?o.case[i]:fo),t?e:fo;return e}}})()),f=xo.empty();return tn(p,f),o.forEach(((t,r)=>{tn(t,a[r],p),on(e[r],t)})),i.forEach(((e,r)=>{tn(e,s[r],p),on(t[r],e)})),tn(n,c,p),on(r,n),f})),Sa=G(3,((e,t,r)=>{if(!d(e))throw new TypeError('"preds" argument of staticArrayCaseT is expected to be type of "Array".');if(!d(t))throw new TypeError('"cases" argument of staticArrayCaseT is expected to be type of "Array".');return e.forEach(((t,r)=>{if(f(t))e[r]=Do(1,xo.of(t));else if(!bo(t))throw new TypeError('"pred" in "preds" argument of staticArrayCaseT are expected to be type of "Function" | "Atom".')})),t.forEach(((e,r)=>{bo(e)||(t[r]=Do(1,xo.of(e)))})),$a(e,t,r)})),ka=G(3,((e,t,r)=>{if(!y(e))throw new TypeError('"preds" argument of objectCaseT is expected to be type of  "Object".');if(!y(t))throw new TypeError('"cases" argument of objectCaseT is expected to be type of  "Object".');if(!bo(r))throw new TypeError('"target" argument of objectCaseT is expected to be type of "Atom".');return Object.values(e).some((e=>!bo(e)))||Object.values(t).some((e=>!bo(e)))?Ia(e,t,r):Ca(e,t,r)})),Ca=G(3,((e,t,r)=>{if(!y(e))throw new TypeError('"preds" argument of dynamicObjectCaseT is expected to be type of "Object".');if(!y(t))throw new TypeError('"cases" argument of dynamicObjectCaseT is expected to be type of  "Object".');if(new Set([...Object.keys(e),...Object.keys(t)]).size!==Object.keys(e).length)throw new TypeError('"preds" & "cases" argument of dynamicObjectCaseT are expected to have same keys.');if(Object.values(e).forEach((e=>{if(!bo(e))throw new TypeError('"pred" in "preds" argument of dynamicObjectCaseT are expected to be type of "Atom".')})),Object.values(t).forEach((e=>{if(!bo(e))throw new TypeError('"case" in "cases" argument of dynamicObjectCaseT are expected to be type of "Atom".')})),!bo(r))throw new TypeError('"target" argument of arrayCaseT is expected to be type of "Atom".');const o=Object.entries(e).reduce(((e,[t])=>(e[t]=vo.ofLiftLeft((e=>({key:t,type:"pred",value:e}))),e)),{}),i=Object.entries(t).reduce(((e,[t])=>(e[t]=vo.ofLiftLeft((e=>({key:t,type:"case",value:e}))),e)),{}),n=vo.ofLiftLeft((e=>({type:"target",value:e}))),a=Object.entries(e).reduce(((e,[t])=>(e[t]=xo.empty(),e)),{}),s=Object.entries(t).reduce(((e,[t])=>(e[t]=xo.empty(),e)),{}),c=xo.empty(),p=vo.ofLiftLeft((()=>{const e={pred:{},case:{},target:!1},t={pred:{},case:{},target:void 0};return r=>{const{key:o,type:i,value:n}=r;if("pred"!==i&&"case"!==i&&"target"!==i)throw new TypeError(`Unexpected type of wrapped Data received in caseM, expected to be "pred" | "case" | "target", but received "${i}".`);if("pred"!==i&&"case"!==i||(e[i][o]=!0,t[i][o]=n),"target"===i&&(e[i]=!0,t[i]=n),!e.target||Object.values(e.pred).some((e=>!e)))return fo;if("pred"===i||"case"===i)return fo;if("target"===i){let r,o=!1;const i=Object.keys(t.pred);for(let n=0,a=i.length;n<a;n++){const a=i[n];if(o)break;return t.pred[a](t.target)&&(o=!0,r=e.case[a]?t.case[a]:fo),o?r:fo}return r}}})()),f=xo.empty();return tn(p,f),Object.entries(o).forEach((([t,r])=>{tn(r,a[t],p),on(e[t],r)})),Object.entries(i).forEach((([e,r])=>{tn(r,s[e],p),on(t[e],r)})),tn(n,c,p),on(r,n),f})),Ia=G(3,((e,t,r)=>{if(!y(e))throw new TypeError('"preds" argument of staticObjectCaseT is expected to be type of "Object".');if(!y(t))throw new TypeError('"cases" argument of staticObjectCaseT is expected to be type of  "Object".');return Object.entries(e).forEach((([t,r])=>{if(f(r))e[t]=Do(1,xo.of(r));else if(!bo(r))throw new TypeError('"pred" in "preds" argument of staticObjectCaseT are expected to be type of "Function" | "Atom".')})),Object.entries(t).forEach((([e,r])=>{bo(r)||(t[e]=Do(1,xo.of(r)))})),Ca(e,t,r)})),Na=(...e)=>{if(bo(e[0])||d(e[0]))return Ua(...e);if(y(e[0]))return Pa(...e);throw new TypeError("Arguments of combineT are expected to be type of Atom | [Atom] | { Atom }.")},Ua=(...e)=>{let t=e[0];d(t)||(t=e);const r=t.map((e=>{if(!bo(e))throw new TypeError('Arguments of combineT are expected to be type of "Atom".');return e})),o=t.length,i=Array.from({length:o}).map(((e,t)=>vo.ofLiftLeft((e=>({id:t,value:e}))))),n=Array.from({length:o}).map((()=>xo.empty())),a=vo.ofLiftLeft((()=>{const e=Array.from({length:o}),t=Array.from({length:o});return r=>{const{id:o,value:i}=r;return no(i)?fo:(e[o]=!0,t[o]=i,[...t])}})()),s=xo.of(Array.from({length:o}));return tn(a,s),n.forEach((e=>{tn(e,a)})),i.forEach(((e,t)=>{tn(e,n[t])})),r.forEach(((e,t)=>{on(e,i[t])})),s},Pa=e=>{const t=Object.entries(e).reduce(((e,[t,r])=>{if(!bo(r))throw new TypeError('Arguments of objectCombineT are expected to be type of "Atom".');return e[t]=r,e}),{}),r=Object.entries(e).reduce(((e,[t])=>(e[t]=vo.ofLiftLeft((e=>({key:t,value:e}))),e)),{}),o=Object.entries(e).reduce(((e,[t])=>(e[t]=xo.empty(),e)),{}),i=vo.ofLiftLeft((()=>{const t=Object.keys(e).reduce(((e,t)=>(e[t]=!1,e)),{}),r=Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{});return e=>{const{key:o,value:i}=e;return no(i)?fo:(t[o]=!0,r[o]=i,{...r})}})()),n=xo.of(Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{}));return tn(i,n),Object.values(o).forEach((e=>{tn(e,i)})),Object.entries(r).forEach((([e,t])=>{tn(t,o[e])})),Object.entries(t).forEach((([e,t])=>{on(t,r[e])})),n},Wa=(...e)=>{if(bo(e[0])||d(e[0]))return Ra(...e);if(y(e[0]))return Ba(...e);throw new TypeError("Arguments of combineLatestT are expected to be type of Atom | [Atom] | { Atom }.")},Ra=(...e)=>{let t=e[0];d(t)||(t=e);const r=t.map((e=>{if(!bo(e))throw new TypeError('Arguments of combineT are expected to be type of "Atom".');return e})),o=t.length,i=Array.from({length:o}).map(((e,t)=>vo.ofLiftLeft((e=>({id:t,value:e}))))),n=Array.from({length:o}).map((()=>xo.empty())),a=vo.ofLiftLeft((()=>{const e=Array.from({length:o}),t=Array.from({length:o});return r=>{const{id:o,value:i}=r;return no(i)?fo:(e[o]=!0,t[o]=i,e.every((e=>e))?[...t]:fo)}})()),s=xo.empty();return tn(a,s),n.forEach((e=>{tn(e,a)})),i.forEach(((e,t)=>{tn(e,n[t])})),r.forEach(((e,t)=>{on(e,i[t])})),s},Ba=e=>{const t=Object.entries(e).reduce(((e,[t,r])=>{if(!bo(r))throw new TypeError('Arguments of objectCombineLatestT are expected to be type of "Atom".');return e[t]=r,e}),{}),r=Object.entries(e).reduce(((e,[t])=>(e[t]=vo.ofLiftLeft((e=>({key:t,value:e}))),e)),{}),o=Object.entries(e).reduce(((e,[t])=>(e[t]=xo.empty(),e)),{}),i=vo.ofLiftLeft((()=>{const t=Object.keys(e).reduce(((e,t)=>(e[t]=!1,e)),{}),r=Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{});return e=>{const{key:o,value:i}=e;return no(i)?fo:(t[o]=!0,r[o]=i,Object.values(t).every((e=>e))?{...r}:fo)}})()),n=xo.empty();return tn(i,n),Object.values(o).forEach((e=>{tn(e,i)})),Object.entries(r).forEach((([e,t])=>{tn(t,o[e])})),Object.entries(t).forEach((([e,t])=>{on(t,r[e])})),n},Va=(...e)=>{let t=e[0];d(t)||(t=e);const r=t.map((e=>{if(!bo(e))throw new TypeError('Arguments of mergeT are expected to be type of "Atom".');return e})),o=vo.ofLiftLeft((e=>e)),i=xo.empty();return tn(o,i),r.forEach((e=>{on(e,o)})),i},qa=(...e)=>{if(bo(e[0])||d(e[0]))return za(...e);if(y(e[0]))return Ha(...e);throw new TypeError("Arguments of zipLatestT are expected to be type of Atom | [Atom] | { Atom }.")},za=(...e)=>{let t=e[0];d(t)||(t=e);const r=t.map((e=>{if(!bo(e))throw new TypeError('Arguments of arrayZipLatestT are expected to be type of "Atom".');return e})),o=Array.from({length:t.length}).map(((e,t)=>vo.ofLiftLeft((e=>({id:t,value:e}))))),i=Array.from({length:t.length}).map((()=>xo.empty())),n=vo.ofLiftLeft((()=>{const e=Array.from({length:t.length}),r=Array.from({length:t.length});return t=>{const{id:o,value:i}=t;return e[o]=!0,r[o]=i,e.every((e=>e))&&r.every((e=>!no(e)))?(e.forEach(((t,r)=>{e[r]=!1})),[...r]):fo}})()),a=xo.empty();return tn(n,a),i.forEach((e=>{tn(e,n)})),o.forEach(((e,t)=>{tn(e,i[t])})),r.forEach(((e,t)=>{on(e,o[t])})),a},Ha=e=>{const t=Object.entries(e).reduce(((e,[t,r])=>{if(!bo(r))throw new TypeError('Arguments of objectZipLatestT are expected to be type of "Atom".');return e[t]=r,e}),{}),r=Object.entries(e).reduce(((e,[t])=>(e[t]=vo.ofLiftLeft((e=>({key:t,value:e}))),e)),{}),o=Object.entries(e).reduce(((e,[t])=>(e[t]=xo.empty(),e)),{}),i=vo.ofLiftLeft((()=>{const t=Object.keys(e).reduce(((e,t)=>(e[t]=!1,e)),{}),r=Object.keys(e).reduce(((e,t)=>(e[t]=void 0,e)),{});return e=>{const{key:o,value:i}=e;return t[o]=!0,r[o]=i,Object.values(t).every((e=>e))&&Object.values(r).every((e=>!no(e)))?(Object.keys(t).forEach((e=>{t[e]=!1})),{...r}):fo}})()),n=xo.empty();return tn(i,n),Object.values(o).forEach((e=>{tn(e,i)})),Object.entries(r).forEach((([e,t])=>{tn(t,o[e])})),Object.entries(t).forEach((([e,t])=>{on(t,r[e])})),n},Ja=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"target" argument of withLatestFromT is expected to be type of "Mutation" or "Data".');if(!bo(t))throw new TypeError('"source" argument of withLatestFromT is expected to be type of "Mutation" or "Data".');const r=vo.ofLiftLeft((e=>({type:"target",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"source",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={target:!1,source:!1},t={target:void 0,source:void 0};return r=>{const{type:o,value:i}=r;if("source"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in withLatestFromM, expected to be "source" | "target", but received "${o}".`);return e[o]=!0,t[o]=i,"target"===o?fo:"source"===o?e.target?[t.source,t.target]:[t.source]:void 0}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Ga=G(2,((e,t)=>{if(f(e))return Qa(e,t);if(bo(e))return Za(e,t);throw new TypeError('"effect" argument of effectT is expected to be type of "Function" or "Atom"')})),Za=G(2,((e,t)=>{if(!bo(e))throw new TypeError('"effect" argument of dynamicEffectT is expected to be type of "Atom".');if(!bo(t))throw new TypeError('"target" argument of dynamicEffectT is expected to be type of "Atom".');const r=vo.ofLiftLeft((e=>({type:"effect",value:e}))),o=xo.empty();tn(r,o);const i=vo.ofLiftLeft((e=>({type:"target",value:e}))),n=xo.empty();tn(i,n);const a=vo.ofLiftLeft((()=>{const e={effect:!1,target:!1},t={effect:void 0,target:void 0};return r=>{const{type:o,value:i}=r;if("effect"!==o&&"target"!==o)throw new TypeError(`Unexpected type of wrapped Data received in effectM, expected to be "effect" | "target", but received "${o}".`);if(e[o]=!0,t[o]=i,!e.effect||!e.target)return fo;if("effect"===o)return fo;if("target"===o){let e,r=!1;const o=t.effect((e=>{a.triggerOperation((()=>e))}),t.target,(t=>{r=!0,e=t}));return r?e:o||fo}}})());tn(o,a),tn(n,a);const s=xo.empty();return tn(a,s),on(e,r),on(t,i),s})),Qa=G(2,((e,t)=>{if(!f(e))throw new TypeError('"effect" argument of staticEffectT is expected to be type of "Function".');return Za(Do(1,xo.of(e)),t)})),Ka=G(2,((e,t)=>(e(t),t))),Xa=(e="",t=0)=>Ka((r=>{a(e)&&(t=e,e=""),t={LOG:"log",INFO:"info",WARN:"warn",ERROR:"error",0:"log",1:"info",2:"warn",3:"error"}[t];const o={log:"#30CFCF",info:"#3030CF",warn:"#CF8030",error:"#CF3030"};return r.subscribe((({value:r})=>{let i="";try{i=JSON.stringify(r)}catch(e){}console[t](`%c ${t.toUpperCase()} %c ${e||"tapLogValueT"}: %c`+r+"%c",`background: ${o[t]}; padding: 1px; border-radius: 3px 0 0 3px; color: #FFFFFF;`,"background: #6600FF; padding: 1px; border-radius: 0 0 0 0; color: #FFFFFF;","background: #66FF00; padding: 1px 10px; border-radius: 0 3px 3px 0; color: #000000;","background: transparent; color: #00000;",r,i)})),r})),Ya=(e={})=>{if(!y(e)&&!f(e))throw new TypeError(`"createOptions" is expected to be type of "Object" | "Function", but received "${typeof e}".`);f(e)&&(e={prepareSingletonLevelContexts:e});const{prepareOptions:t=(e=>e),prepareDriverLevelContexts:r=(()=>({})),prepareSingletonLevelContexts:o=(e=>({})),prepareInstance:i=((e,t,r)=>({...r}))}=e;if(!f(t))throw new TypeError(`"prepareOptions" is expected to be type of "Function", but received "${typeof t}".`);if(!f(r))throw new TypeError(`"prepareDriverLevelContexts" is expected to be type of "Function", but received "${typeof r}".`);if(!f(o))throw new TypeError(`"prepareSingletonLevelContexts" is expected to be type of "Function", but received "${typeof o}".`);if(!f(i))throw new TypeError(`"prepareInstance" is expected to be type of "Function", but received "${typeof i}".`);const n=r();if(!y(n))throw new TypeError(`"driverLevelContexts" is expected to be type of "Object", but received "${typeof n}"`);return(e={})=>{if(!y(e))throw new TypeError(`"options" is expected to be type of "Object", but received "${typeof e}".`);if(e=t(e),!y(e))throw new TypeError(`The returned value of "prepareOptions" is expected to be type of "Object", but received "${typeof e}".`);const r=o(e,n);if(!y(r))throw new TypeError(`"singletonLevelContexts" is expected to be type of "Object", but received "${typeof r}"`);const{inputs:a={},outputs:s={}}=r;if(!y(a))throw new TypeError(`"inputs" returned as singletonLevelContexts is expected to be type of "Object", but received "${typeof a}"`);if(!y(s))throw new TypeError(`"outputs" returned as singletonLevelContexts is expected to be type of "Object", but received "${typeof s}"`);return i(e,n,r)}},es=e=>{if(!y(e))throw new TypeError(`"interfaces" is expected to be type of "Object", but received "${typeof e}"`);const{inputs:{...t}={},outputs:{...r}={}}=e;if(!y(t))throw new TypeError(`"inputs" of interfaces is expected to be type of "Object", but received "${typeof t}"`);if(!y(r))throw new TypeError(`"outputs" of interfaces is expected to be type of "Object", but received "${typeof r}"`);return Object.entries(e).forEach((([e,r])=>{"inputs"!==e&&"outputs"!==e&&(t[e]=r)})),{inputs:{...t},outputs:{...r}}},ts=(e,t)=>{const r=e=>bo(e)?Do(1,e):Do(1,xo.of(e));if(bo(e)&&!bo(t))d(t)&&t.forEach((t=>{bo(t)&&on(r(e),t)}));else if(bo(e)&&bo(t))on(r(e),t);else if(!bo(e)&&bo(t))on(r(e),t);else if(y(e)&&y(t))Object.entries(e).forEach((([e,r])=>{t[e]&&ts(r,t[e])}));else{if(!d(e)||!d(t))throw new TypeError("The up interfaces & down interfaces are expected to be the type combinations as follows: (Atom, Any) | (Any, Atom) | (Object | Object) | (Array | Array).");e.forEach(((e,r)=>{t[r]&&ts(e,t[r])}))}},rs=Q(3,((e,t,r)=>{const o=e(t),{inputs:{...i}={},outputs:{...n}={},...a}={...o},{inputs:{...s}={},outputs:{...c}={}}={...es(r)};return ts(s,i),ts(n,c),{inputs:i,outputs:n,...a}})),os={equiped:K,equip:ve};return t})()}));